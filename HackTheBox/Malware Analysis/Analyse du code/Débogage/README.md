Débogage
========

Le débogage ajoute une couche dynamique et interactive à l'analyse du code, offrant une vue en temps réel du comportement des logiciels malveillants. Il permet aux analystes de confirmer leurs découvertes, d'être témoins des impacts sur l'exécution et d'approfondir leur compréhension de l'exécution du programme. L'association de l'analyse du code et du débogage permet une compréhension globale des logiciels malveillants, conduisant à une exposition efficace des comportements nuisibles.

Nous pourrions déployer un débogueur tel que `x64dbg`, un outil convivial conçu pour analyser et déboguer les exécutables Windows 64 bits. Il est équipé d'une interface graphique pour visualiser le code démonté, implémenter des points d'arrêt, examiner la mémoire et les registres et contrôler l'exécution des programmes.

Naviguons maintenant vers le bas de cette section et cliquons sur "Cliquez ici pour générer le système cible !". Ensuite, passons à RDP dans l'adresse IP cible en utilisant les informations d'identification fournies. La grande majorité des actions/commandes couvertes de ce point à la fin de cette section peuvent être répliquées dans la cible, offrant ainsi une compréhension plus complète des sujets présentés.

```
dsgsec@htb[/htb]$ xfreerdp /u:htb-student /p:'HTB_@cademy_stdnt!' /v:[Target IP] /dynamic-resolution

```

Voici comment exécuter un exemple `x64dbg`pour vous familiariser avec ses opérations.

-   Lancez `x64dbg`.
-   En haut de l' `x64dbg`interface, cliquez sur le `File`menu.
-   Sélectionnez `Open`pour choisir le fichier exécutable que nous souhaitons déboguer.
-   Accédez au répertoire contenant l'exécutable et sélectionnez-le.
-   Facultativement, des arguments de ligne de commande ou le répertoire de travail peuvent être spécifiés dans la boîte de dialogue qui apparaît.
-   Cliquez `OK`pour charger l'exécutable dans `x64dbg`.

Lors de l'ouverture, la fenêtre par défaut s'arrête à un point d'arrêt par défaut au point d'entrée du programme.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_001_views.png)

Le chargement d'un exécutable `x64dbg`révèle la vue de désassemblage, présentant les instructions d'assemblage du programme, aidant ainsi à comprendre le flux de code. À droite, la fenêtre de registre divulgue les valeurs des registres du CPU, mettant en lumière l'état du programme. Sous la fenêtre de registre, la vue de la pile affiche le cadre de pile actuel, permettant l'inspection des appels de fonction et des variables locales. Enfin, dans le coin inférieur gauche, nous trouvons la vue de vidage mémoire, fournissant une représentation picturale de la mémoire du programme, facilitant l'analyse des structures de données et des variables.

Simulation de services Internet
-------------------------------

Le rôle de `INetSim`dans la simulation des services Internet typiques dans notre environnement de test restreint est essentiel. Il prend en charge une multitude de services, notamment `DNS`, `HTTP`, `FTP`, `SMTP`, entre autres. Nous pouvons l'affiner pour reproduire des réponses spécifiques, permettant ainsi un examen plus personnalisé du comportement du malware. Notre approche consistera à rester `InetSim`opérationnel afin qu'il puisse intercepter toute requête `DNS`, `HTTP`, ou autre émanant de l'échantillon de malware ( `shell.exe`), lui fournissant ainsi des réponses synthétiques et contrôlées.

Remarque : Il est fortement recommandé d'utiliser votre propre VM/machine pour exécuter `InetSim`. Notre VM/machine doit être connectée au VPN à l'aide du fichier de configuration VPN fourni qui réside à la fin de cette section.

Nous devrions configurer `INetSim`comme suit.

```
dsgsec@htb[/htb]$ sudo nano /etc/inetsim/inetsim.conf

```

Les éléments ci-dessous doivent être décommentés et spécifiés.

```
service_bind_address <Our machine's/VM's TUN IP>
dns_default_ip <Our machine's/VM's TUN IP>
dns_default_hostname www
dns_default_domainname iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com

```

L'initiation `INetSim`implique l'exécution de la commande suivante.

```
dsgsec@htb[/htb]$ sudo inetsim
INetSim 1.3.2 (2020-05-19) by Matthias Eckert & Thomas Hungenberg
Using log directory:      /var/log/inetsim/
Using data directory:     /var/lib/inetsim/
Using report directory:   /var/log/inetsim/report/
Using configuration file: /etc/inetsim/inetsim.conf
Parsing configuration file.
Configuration file parsed successfully.
=== INetSim main process started (PID 34711) ===
Session ID:     34711
Listening on:   0.0.0.0
Real Date/Time: 2023-06-11 00:18:44
Fake Date/Time: 2023-06-11 00:18:44 (Delta: 0 seconds)
 Forking services...
  * dns_53_tcp_udp - started (PID 34715)
  * smtps_465_tcp - started (PID 34719)
  * pop3_110_tcp - started (PID 34720)
  * smtp_25_tcp - started (PID 34718)
  * http_80_tcp - started (PID 34716)
  * ftp_21_tcp - started (PID 34722)
  * https_443_tcp - started (PID 34717)
  * pop3s_995_tcp - started (PID 34721)
  * ftps_990_tcp - started (PID 34723)
 done.
Simulation running.

```

Une ressource plus élaborée sur la configuration `INetSim`est la suivante : <https://medium.com/@xNymia/malware-analysis-first-steps-creating-your-lab-21b769fb2a64>

Enfin, le DNS de la cible générée doit pointer vers la machine/VM sur laquelle `INetSim`s'exécute.

![Image](https://academy.hackthebox.com/storage/modules/227/point_.png)

Application des correctifs pour contourner les vérifications Sandbox
--------------------------------------------------------------------

Étant donné que les contrôles sandbox entravent l'exécution directe du malware sur la machine, nous devons corriger ces contrôles pour contourner la détection sandbox. Voici comment nous pouvons éviter les contrôles de détection du bac à sable lors du débogage avec `x64dbg`. Plusieurs méthodes peuvent nous conduire aux instructions dans lesquelles la détection du bac à sable est effectuée. Nous en discuterons quelques-uns.

### En copiant l'adresse de l'IDA

Lors de l'analyse du code, nous avons observé la vérification de détection du sandbox liée à la clé de registre. Nous pouvons extraire l'adresse de la première `cmp`instruction directement de `IDA`.

Pour trouver l'adresse, revenons aux fenêtres IDA, ouvrons la première fonction que nous avions renommée `assumed_Main`et recherchons l' `cmp`instruction. Pour afficher les adresses, nous pouvons passer de la vue graphique à la vue texte en appuyant sur le bouton de la barre d'espace.

Cela expose l'adresse (comme souligné dans la capture d'écran ci-dessous)

Nous pouvons copier l'adresse `00000000004032C8`de `IDA`.

Code : ida

```
.text:00000000004032C8                 cmp     [rsp+148h+Type], 1

```

Dans `x64dbg`, nous pouvons cliquer avec le bouton droit n'importe où sur la vue de démontage (CPU) et sélectionner `Go to`> `Expression`. Alternativement, nous pouvons appuyer sur `Ctrl+G`(aller à l'expression) comme raccourci.

Nous pouvons saisir ici l'adresse copiée, comme indiqué dans la capture d'écran. Cela nous dirige vers l'instruction de comparaison où nous pouvons mettre en œuvre des modifications.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_027_addresscp.png)

### En recherchant dans les chaînes.

Recherchons `Sandbox detected`dans le `String references`, et définissons un `breakpoint`, de sorte que lorsque nous appuyons sur Exécuter, l'exécution s'arrête à ce stade.

Pour ce faire, cliquez d'abord `Run`une fois sur le bouton, puis cliquez avec le bouton droit n'importe où dans la vue de démontage et choisissez `Search for`> `Current Module`> `String references`.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_002_strings_.png)

Ensuite, nous pouvons ajouter un point d'arrêt pour marquer l'emplacement, puis étudier les instructions avant ce bac à sable `MessageBox`pour discerner comment le saut a été effectué vers l'impression des instructions `Sandbox detected`.

Commençons par ajouter un point d'arrêt à la dernière `Sandbox detected`chaîne comme suit.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_002_strings__.png)

On peut alors double-cliquer sur la chaîne pour se rendre à l'adresse où `Sandbox detected`se trouvent les instructions à imprimer.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_003_cmp.png)

Comme observé, une `cmp`instruction est présente au-dessus `MessageBox`qui compare la valeur avec `1`après qu'une comparaison du chemin de registre a été effectuée. Modifions `0`plutôt cette valeur de comparaison pour qu'elle corresponde. Cela peut être fait en plaçant le curseur sur cette instruction et en appuyant `Spacebar`sur le clavier. Cela nous permet de modifier les instructions du code assembleur.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_004_assemble_patch1.png)

Nous pouvons changer la valeur de comparaison de `0x1`à `0x0`. Changer la comparaison en `0`peut décaler le flux de contrôle du code, et il ne doit pas passer à l'adresse où `MessageBox`est affiché.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_004_patch1.png)

En cliquant sur `Run`ou `x64dbg`en appuyant sur `F9`, il n'atteindra pas le point d'arrêt du premier code de message de détection du bac à sable. Cela signifie que nous avons correctement corrigé les instructions.

De la même manière, nous pouvons ajouter un point d'arrêt sur la prochaine fonction de détection du bac à sable avant qu'elle n'imprime `MessageBox`également un. Pour ce faire, le point d'arrêt doit être placé au niveau de la `second to last` `Sandbox detected`chaîne ( `0000000000402F13`). Si nous double-cliquons sur cette chaîne, nous remarquerons qu'il y a une `jump`instruction que nous pouvons ignorer, dirigeant le flux d'exécution vers l'instruction suivante qui appelle une autre fonction. C'est exactement ce dont nous avons besoin : au lieu de la détection du bac à sable `MessageBox`, il passe à une autre fonction.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_005_patch2.png)

Nous pouvons modifier l'instruction de `je shell.402F09`à `jne shell.402F09`.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_006_jne.png)

`shell.exe`effectue la détection du bac à sable en vérifiant la connectivité Internet. La cible de cette section ne dispose pas de connectivité Internet. Pour cette raison, nous devrions également corriger cette méthode de détection sandbox. Nous pouvons le faire en cliquant sur la première `Sandbox detected`chaîne ( `0000000000402CBD`) et en corrigeant l'instruction suivante.

![Image](https://academy.hackthebox.com/storage/modules/227/patch3.png)

![Image](https://academy.hackthebox.com/storage/modules/227/patch3_.png)

Maintenant, lorsque nous appuyons sur `Run`, le correctif `shell.exe`continue, télécharge l'exécutable par défaut à partir de `INetSim`et l'exécute.

![Image](https://academy.hackthebox.com/storage/modules/227/both_messagebox.png)

Une fois les contrôles sandbox contournés, la fonctionnalité réelle est dévoilée. Nous pouvons enregistrer l'exécutable corrigé en appuyant `Ctrl+P`et en cliquant sur `Patch File`. Cette action stocke le fichier corrigé, ce qui ignore les vérifications du bac à sable.

![Image](https://academy.hackthebox.com/storage/modules/227/patch3__.png)

Nous entreprenons ce processus pour nous assurer que la prochaine fois que nous exécuterons le fichier corrigé enregistré, il s'exécutera directement sans les vérifications du bac à sable et que nous pourrons observer tous les événements dans `ProcessMonitor`.

Analyse du trafic de logiciels malveillants
-------------------------------------------

Gardez à l'esprit que l'analyse du trafic peut non seulement l'être, mais devrait idéalement être intégrée comme partie intégrante de l'analyse dynamique.

Utilisons maintenant `Wireshark`, pour capturer et examiner le trafic réseau généré par le malware. Faites attention au trafic codé par couleur : le rouge correspond au trafic client-serveur, tandis que le bleu désigne les échanges serveur-client.

L'examen de la requête HTTP révèle que l'échantillon de logiciel malveillant ajoute le nom d'hôte de l'ordinateur au champ de l'agent utilisateur (dans ce cas, il s'agissait de `RDSEMVM01`).

![Image](https://academy.hackthebox.com/storage/modules/227/wireshark_request.png)

Lors de l'inspection de la réponse HTTP, il devient évident qu'elle `InetSim`a renvoyé son binaire par défaut en réponse au malware.

![Image](https://academy.hackthebox.com/storage/modules/227/wireshark_response.png)

La requête du malware `svchost.exe`sollicite le binaire par défaut de `InetSim`. Ce binaire répond par un `MessageBox`message comportant le message : `This is the INetSim default binary`.

De plus, des requêtes DNS pour un domaine aléatoire et l'adresse `ms-windows-update[.]com`ont été envoyées par le malware, avec `INetSim`de fausses réponses (dans ce cas, `INetSim`elles fonctionnaient sur `10.10.10.100`).

![Image](https://academy.hackthebox.com/storage/modules/227/wireshark_dns.png)

Analyse de l'injection de processus et de la région mémoire
-----------------------------------------------------------

Au cours de l'analyse du code, nous avons découvert que notre exécutable effectue une injection de processus `notepad.exe`et affiche un `MessageBox`message `Connection sent to C2`.

Pour approfondir l'injection de processus, nous proposons de définir des points d'arrêt au niveau des fonctions WINAPI `VirtualAllocEx`, `WriteProcessMemory`et `CreateRemoteThread`. Ces points d'arrêt nous permettront d'examiner le contenu contenu dans les registres lors de l'injection du processus. Voici la procédure pour définir ces points d'arrêt :

-   Accédez à l' `x64dbg`interface et accédez à l' `Symbols`onglet situé en haut.
-   Dans la zone de recherche de symboles, recherchez le nom de la DLL souhaité à gauche et les noms de fonctions, tels que `VirtualAllocEx`, `WriteProcessMemory`et `CreateRemoteThread`, à droite dans la `Kernel32.dll`DLL.
-   Au fur et à mesure que les noms de fonctions se matérialisent dans les résultats de la recherche, cliquez avec le bouton droit et sélectionnez `Toggle breakpoint`dans le menu contextuel pour chaque fonction. Un autre raccourci consiste à appuyer sur `F2`.

L'exécution de ces étapes définit un point d'arrêt au point d'entrée de chaque fonction. Nous reproduirons ces étapes pour toutes les fonctions que nous avons l'intention d'examiner.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_008_bp_wpm.png)

Après avoir défini les points d'arrêt, nous appuyons `F9`ou sélectionnons `Run`dans la barre d'outils jusqu'à ce que nous atteignions le point d'arrêt pour `WriteProcessMemory`. Jusqu'à présent, `notepad`a été lancé, mais `shellcode`n'a pas encore été écrit dans la mémoire du bloc-notes.

### Attacher un autre processus en cours d'exécution dans x64dbg

Afin d'aller plus loin, ouvrons une autre instance de `x64dbg`et attachons-la à `notepad.exe`.

-   Démarrez une nouvelle instance de `x64dbg`.
-   Accédez au `File`menu et sélectionnez `Attach`ou utilisez le `Alt + A`raccourci clavier.
-   Dans la `Attach`boîte de dialogue, une liste des processus en cours apparaîtra. Choisissez `notepad.exe`dans la liste.
-   Cliquez sur le `Attach`bouton pour commencer le processus de pièce jointe.

Une fois la pièce jointe réussie, `x64dbg`lance le débogage du processus cible et la fenêtre principale affiche le code assembleur ainsi que d'autres informations de débogage.

Désormais, nous pouvons établir des points d'arrêt, parcourir le code, inspecter les registres et la mémoire et étudier le comportement du processus notepad.exe ci-joint à l'aide de `x64dbg`.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_009_attach.png)

Le deuxième argument de `WriteProcessMemory`est `lpBaseAddress`qui contient un pointeur vers l'adresse de base du processus spécifié dans lequel les données sont écrites. Dans notre cas, cela devrait être dans le `RDX`registre.

![Image](https://academy.hackthebox.com/storage/modules/227/msdn_002_writeprocessmemory.png)

Lors de l'appel de la `WriteProcessMemory`fonction, le `rdx`registre contient le `lpBaseAddress`paramètre. Ce paramètre représente l'adresse dans l'espace d'adressage du processus cible où les données seront écrites.

Notre objectif est d'examiner les registres lorsque la `WriteProcessMemory`fonction est invoquée dans l' `x64dbg`instance exécutant le `shell.exe`processus. Cela révélera l'adresse à `notepad.exe`laquelle le shellcode sera écrit.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_010_register_wpm.png)

Nous copions cette adresse pour examiner son contenu dans le dump mémoire du `notepad.exe`processus attaché dans un deuxième `x64dbg`temps.

Nous sélectionnons maintenant `Go to`> `Expression`en cliquant avec le bouton droit n'importe où sur l'image mémoire de la deuxième `x64dbg`instance en cours d'exécution `notepad.exe`.

Une fois l'adresse copiée saisie, le contenu de cette adresse est affiché (en cliquant avec le bouton droit sur l'adresse et en choisissant `Follow in Dump`> `Selected Address`), qui est actuellement vide.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_011_shellcode_write.png)

Ensuite, nous exécutons shell.exe en premier `x64dbg`lieu en cliquant sur le `Run`bouton. Nous observons ce qui est inscrit dans cette région mémoire de `notepad.exe`.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_shellcodecopy_.png)

Suite à son exécution, nous identifions le injecté `shellcode`, ce qui correspond à ce que nous avons découvert plus tôt lors de l'analyse du code. Nous pouvons le vérifier `Process Hacker`et l'enregistrer dans un fichier pour un examen ultérieur.