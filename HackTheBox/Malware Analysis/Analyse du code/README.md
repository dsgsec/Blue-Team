Analyse du code
===============

Ingénierie inverse et analyse de code
-------------------------------------

`Reverse engineering`est un processus qui nous emmène sous la surface des fichiers exécutables ou du code machine compilé, nous permettant de décoder leurs fonctionnalités, leurs traits comportementaux et leur structure. En l'absence de code source, nous nous tournons vers l'analyse des instructions de code désassemblées, également appelées `assembly code analysis`. Ce niveau de compréhension plus profond nous aide à découvrir des fonctionnalités obscurcies ou insaisissables qui restent cachées même après une analyse statique et dynamique.

Pour démêler le réseau complexe du code machine, nous nous tournons vers un duo d'outils puissants : `Disassemblers`et `Debuggers`.

-   A `Disassembler`est notre outil de choix lorsque nous souhaitons effectuer une analyse statique du code, ce qui signifie que nous n'avons pas besoin d'exécuter le code. Ce type d'analyse est inestimable car il nous aide à comprendre la structure et la logique du code sans activer de fonctionnalités potentiellement nuisibles. Quelques exemples de désassembleurs incluent `IDA`, `Cutter`, et `Ghidra`.

-   A `Debugger`, en revanche, remplit un double objectif. Comme un désassembleur, il décode le code machine en instructions d'assemblage. De plus, cela nous permet d'exécuter du code de manière contrôlée, en procédant instruction par instruction, en sautant vers des emplacements spécifiques ou en arrêtant le flux d'exécution à des points désignés à l'aide de points d'arrêt. Des exemples de débogueurs incluent `x32dbg`, `x64dbg`, `IDA`et `OllyDbg`.

Prenons du recul et comprenons le défi qui nous attend. Le voyage du code depuis des langages de haut niveau lisibles par l'homme, tels que C ou C++, vers `machine code`est un aller simple, guidé par le compilateur. `Machine code`, un langage binaire que les ordinateurs traitent directement, est un récit énigmatique pour les analystes humains. C'est ici qu'intervient le langage assembleur, agissant comme un pont entre nous et le code machine, nous permettant de décoder l'histoire de ce dernier.

Un désassembleur retransforme le code machine en langage assembleur, nous présentant une séquence d'instructions lisible. Comprendre l'assembly et ses mnémoniques est essentiel pour disséquer les fonctionnalités des logiciels malveillants.

* * * * *

`Code analysis`est le processus d'examen et de déchiffrement du comportement et des fonctionnalités d'un programme compilé ou d'un binaire. Cela implique d'analyser les instructions, le flux de contrôle et les structures de données au sein du code, pour finalement mettre en lumière l'objectif, la fonctionnalité et le potentiel `indicators of compromise (IOCs)`.

Comprendre un programme ou un malware nécessite souvent d'inverser le processus de compilation. C'est là `Disassembly`qu'intervient l'image. En reconvertissant le code machine en instructions en langage assembleur, nous obtenons un ensemble d'instructions symboliques et mnémoniques, nous permettant de décoder la logique et le fonctionnement du programme.

![Image](https://academy.hackthebox.com/storage/modules/227/disassembly.png)

Les désassembleurs sont nos alliés dans ce processus. Ces outils spécialisés prennent le code binaire, génèrent les instructions d'assemblage correspondantes et les complètent souvent avec un contexte supplémentaire tel que des adresses mémoire, des noms de fonctions et une analyse du flux de contrôle. L'un de ces outils puissants est [IDA](https://hex-rays.com/ida-free/) , un désassembleur et débogueur largement utilisé et vénéré pour ses fonctionnalités d'analyse avancées. Il prend en charge plusieurs formats et architectures de fichiers exécutables, présentant une vue complète de désassemblage et de puissantes capacités d'analyse.

Naviguons maintenant vers le bas de cette section et cliquons sur "Cliquez ici pour générer le système cible !". Ensuite, passons à RDP dans l'adresse IP cible en utilisant les informations d'identification fournies. La grande majorité des actions/commandes couvertes de ce point à la fin de cette section peuvent être répliquées dans la cible, offrant ainsi une compréhension plus complète des sujets présentés.

```
dsgsec@htb[/htb]$ xfreerdp /u:htb-student /p:'HTB_@cademy_stdnt!' /v:[Target IP] /dynamic-resolution

```

Exemple d'analyse de code : shell.exe
-------------------------------------

Continuons avec l'analyse de l' `shell.exe`échantillon de malware résidant dans le `C:\Samples\MalwareAnalysis`répertoire cible de cette section. Jusqu'à présent, nous avons découvert qu'il exécute `sandbox detection`et qu'il inclut un éventuel mécanisme de mise en veille - un `5-second ping`délai - avant d'exécuter les opérations prévues.

### Importation d'un échantillon de logiciel malveillant dans le désassembleur - IDA

Pour la prochaine étape de notre enquête, nous devons examiner le code pour `IDA`vérifier ses actions ultérieures et découvrir comment contourner la vérification sandbox utilisée par l'échantillon de malware.

Nous pouvons lancer `IDA`soit en double-cliquant sur le `IDA`raccourci placé sur le bureau, soit en cliquant dessus avec le bouton droit et en sélectionnant `Run as administrator`pour garantir les droits d'accès appropriés. Dans un premier temps, il affichera les informations de licence et nous invitera ensuite à ouvrir un nouvel exécutable pour analyse.

Ensuite, optez pour `New`et sélectionnez l' `shell.exe`échantillon résidant dans le `C:\Samples\MalwareAnalysis`répertoire de la cible de cette section à disséquer.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_intro.png)

La `Load a new file`boîte de dialogue qui apparaît ensuite permet de sélectionner l'architecture du processeur. Choisissez le bon et cliquez sur `OK`. Par défaut, `IDA`détermine le type de processeur approprié.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_intro_processor.png)

Après avoir appuyé sur `OK`, `IDA`nous chargerons le fichier exécutable en mémoire et désassemblerons le code machine pour nous restituer la sortie désassemblée. La capture d'écran ci-dessous illustre les différentes vues dans `IDA`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_intro_views.png)

Une fois l'exécutable chargé et l'analyse terminée, le code démonté de l'échantillon `shell.exe`sera affiché dans la `IDA-View`fenêtre principale. Nous pouvons parcourir le code à l'aide des touches du curseur ou de la barre de défilement et effectuer un zoom avant ou arrière à l'aide de la molette de la souris ou des commandes de zoom.

### Vues texte et graphique

Le code désassemblé est présenté en deux modes, à savoir le `Graph view`et le `Text view`. La vue par défaut est la `Graph view`, qui fournit une illustration graphique des blocs de base de la fonction et de leurs interconnexions. Les blocs de base sont des séquences d'instructions avec un seul point d'entrée et de sortie. Ces blocs de base sont symbolisés sous forme de nœuds dans la vue graphique, avec les connexions entre eux sous forme d'arêtes.

Pour basculer entre les vues graphique et texte, appuyez simplement sur le `spacebar`bouton.

-   Le `Graph view`offre une représentation picturale du flux de contrôle du programme, facilitant une meilleure compréhension du flux d'exécution, l'identification des boucles, des conditions et des sauts, et une visualisation de la façon dont le programme se branche ou parcourt différents chemins de code.

    ![Image](https://academy.hackthebox.com/storage/modules/227/ida_graph_view.png)

    Les fonctions sont affichées comme `nodes`dans le `Graph view`. Chaque fonction est représentée comme un nœud distinct avec un identifiant unique et des détails supplémentaires tels que `function name`, `address`, et `size`.

-   L' `Text view`affiche les instructions d'assemblage ainsi que leurs adresses mémoire correspondantes. Chaque ligne du `Text view`représente un `instruction or a data element`dans le code, en commençant par le `section name:virtual address`format (par exemple, `.text:00000000004014F0`où le nom de la section est `.text`et l'adresse virtuelle est `00000000004014F0`).

    Code : ida

    ```
    text:00000000004014F0 ; =============== S U B R O U T I N E =======================================
    text:00000000004014F0
    text:00000000004014F0
    text:00000000004014F0                 public start
    text:00000000004014F0 start           proc near               ; DATA XREF: .pdata:000000000040603C↓o
    text:00000000004014F0
    text:00000000004014F0 ; FUNCTION CHUNK AT 			.text:00000000004022A0 SIZE 000001B0 BYTES
    text:00000000004014F0
    text:00000000004014F0 ; __unwind { // __C_specific_handler
    text:00000000004014F0                 sub     rsp, 28h
    text:00000000004014F4
    text:00000000004014F4 loc_4014F4:                             ; DATA XREF: .xdata:0000000000407058↓o
    text:00000000004014F4 ;   __try { // __except at loc_40150C
    text:00000000004014F4                 mov     rax, cs:off_405850
    text:00000000004014FB                 mov     dword ptr [rax], 0
    text:0000000000401501                 call    sub_401650
    text:0000000000401506                 call    sub_401180
    text:000000000040150B                 nop
    text:000000000040150B ;   } // starts at 4014F4

    ```

    ![Image](https://academy.hackthebox.com/storage/modules/227/ida_text_view.png)

    `IDA`utilise des `Text view`flèches pour signifier différents types d'instructions et de sauts de flux de contrôle. Voici quelques flèches fréquemment vues et leurs interprétations :

    -   `Solid Arrow (→)`: Une flèche pleine désigne une instruction de saut ou de branchement direct, indiquant un changement inconditionnel dans le flux du programme où l'exécution se déplace d'un emplacement à un autre. Cela se produit lorsqu'une instruction de saut ou de branchement comme `jmp`ou `call`est rencontrée.
    -   `Dashed Arrow (---→)`: Une flèche en pointillés représente une instruction de saut ou de branchement conditionnel, suggérant que le déroulement du programme peut changer en fonction d'une condition spécifique. La destination du saut dépend de l'issue de la condition. Par exemple, une `jz`instruction (saut si zéro) déclenchera un saut uniquement si une comparaison précédente a donné une valeur nulle. ![Image](https://academy.hackthebox.com/storage/modules/227/ida_text_view_arrows.png)

Par défaut, IDA affiche initialement la fonction principale ou la fonction au point d'entrée désigné du programme. Cependant, nous avons la liberté d'explorer et d'examiner d'autres fonctions dans la vue graphique.

### Reconnaître la fonction principale de l'IDA

La capture d'écran suivante montre la `start`fonction, qui constitue le point d'entrée du programme et est généralement responsable de la configuration de l'environnement d'exécution avant d'appeler la `main`fonction réelle. Il s'agit de la `start`fonction initiale affichée par IDA après le chargement de l'exécutable.

![Image](https://academy.hackthebox.com/storage/modules/227/ida__001_start.png)

Notre objectif est de localiser la fonction principale réelle, ce qui nécessite une exploration plus approfondie du démontage. Nous rechercherons les appels de fonction ou les sauts qui mènent à d'autres fonctions, car l'un d'eux est probablement la fonction principale. `IDA`La vue graphique, les références croisées ou la liste de fonctions peuvent aider à naviguer dans le démontage et à identifier la `main`fonction.

Cependant, pour atteindre la `main`fonction, nous devons d'abord comprendre la fonction de cette `start`fonction. Cette fonction consiste principalement en du code d'initialisation, de la gestion des exceptions et des appels de fonction. Il passe finalement à l' `loc_40150C`étiquette, qui est un gestionnaire d'exceptions. Par conséquent, nous pouvons en déduire qu'il ne s'agit pas de la fonction principale réelle où réside généralement la logique du programme. Nous inspecterons les autres appels de fonction pour identifier la `main`fonction.

Le code commence par soustraire `0x28`(40 en décimal) du `rsp`registre (pointeur de pile), créant ainsi de l'espace sur la pile pour les variables locales et préservant le contenu de la pile précédente.

Code : ida

```
public start
start proc near

; FUNCTION CHUNK AT .text:00000000004022A0 SIZE 000001B0 BYTES

; __unwind { // __C_specific_handler
sub     rsp, 28h

```

Le bloc du milieu dans la capture d'écran ci-dessus représente un mécanisme de gestion des exceptions utilisé `structured exception handling (SEH)`dans le code. Les mots-clés `__try`et `__except`suggèrent la configuration d'un bloc de gestion des exceptions. Dans ce cadre, les instructions suivantes `call`appellent deux sous-programmes (fonctions) nommés respectivement `sub_401650`et . `sub_401180`Il s'agit de noms d'espace réservé générés automatiquement par IDA pour désigner les sous-programmes, les emplacements de programme et les données. Les noms générés automatiquement portent généralement l'un des préfixes suivants suivi de leurs adresses virtuelles correspondantes : `sub_<virtual_address>`ou `loc_<virtual_address>`etc.

Code : ida

```
loc_4014F4:
;   __try { // __except at loc_40150C
mov     rax, cs:off_405850
mov     dword ptr [rax], 0
call    sub_401650         ; Will inspect this function
call    sub_401180         ; Will inspect this function
nop
;   } // starts at 4014F4

-----------------------------------------------

loc_40150C:
;   __except(TopLevelExceptionFilter) // owned by 4014F4
nop
add     rsp, 28h
retn
; } // starts at 4014F0
start endp

```

### Navigation dans les fonctions dans IDA

Inspectons le contenu de ces deux fonctions `sub_401650`et `sub_401180`en naviguant dans chaque fonction pour parcourir le code démonté.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_function_calls.png)

Nous allons dans un premier temps ouvrir la première fonction/sous-programme `sub_401650`. Pour entrer une fonction dans `IDA`la vue de désassemblage de , placez le curseur sur l'instruction qui représente l'appel de fonction (ou l'instruction de saut) que nous voulons suivre, puis cliquez avec le bouton droit sur l'instruction et sélectionnez-la `Jump to Operand`dans le menu contextuel. Alternativement, nous pouvons appuyer `Enter`sur la touche de notre clavier.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_function_enter.png)

Ensuite, `IDA`nous guidera vers l'emplacement cible du saut ou de l'appel de fonction, nous emmenant au début de la fonction appelée ou à la destination du saut.

Maintenant que nous sommes dans la première fonction/sous-programme `sub_401650`, efforçons-nous de la comprendre afin de déterminer si c'est bien la `main`fonction. Sinon, nous naviguerons dans d'autres fonctions et discernerons l'appel à la `main`fonction.

Dans ce sous-programme `sub_401650`, nous pouvons voir des instructions d'appel aux fonctions telles que `GetSystemTimeAsFileTime`, `GetCurrentProcessId`, `GetCurrentThreadId`, `GetTickCount`, et `QueryPerformanceCounter`. Ce modèle est fréquemment observé au début du code exécutable désassemblé et consiste généralement à configurer le cadre de pile initial et à effectuer certaines tâches d'initialisation liées au système.

![Image](https://academy.hackthebox.com/storage/modules/227/ida__002_initial_stack.png)

Le type d'instructions détaillé ici se trouve généralement dans le code exécutable produit par les compilateurs ciblant l'architecture x86/x64. Lorsqu'un exécutable est chargé et exécuté par le système d'exploitation, il incombe au système d'exploitation de préparer l'environnement d'exécution du programme. Ce processus implique des tâches telles que la configuration de la pile, l'initialisation du registre et la préparation des structures de données pertinentes pour le système.

D'une manière générale, cette section de code fait partie de la configuration initiale de l'environnement d'exécution, effectuant les tâches d'initialisation nécessaires liées au système avant l'exécution de la logique principale du programme. L'objectif ici est de garantir que le programme se lance dans un état cohérent, avec un accès aux ressources et informations système nécessaires. Pour clarifier, ce n'est pas là que réside la logique principale du programme, et nous devons donc explorer d'autres appels de fonction pour identifier la `main`fonction.

Revenons et ouvrons le deuxième sous-programme, `sub_401180`, pour examiner son contenu.

* * * * *

Pour revenir à la fonction précédente que nous examinions, nous pouvons appuyer `Esc`sur la touche de notre clavier, ou bien, nous pouvons cliquer sur le `Jump Back`bouton dans la barre d'outils.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_go_back.png)

`IDA`nous ramènera à la fonction précédente que nous inspections `(loc_4014F4`), nous emmenant là où nous étions avant de passer à la fonction ou à l'emplacement actuel. Nous revenons maintenant à l'emplacement précédent, qui contient les instructions d'appel à la fonction actuelle, `sub_401650`, ainsi qu'une autre fonction, `sub_401180`.

De là, nous pouvons positionner le curseur sur l'instruction d'appeler `sub_401180`et appuyer sur `Enter`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_go_back_enter.png)

Cela nous guidera dans la fonction `sub_401180`, où nous nous efforcerons d'identifier la `main`fonction dans laquelle se situe la logique du programme.

![Image](https://academy.hackthebox.com/storage/modules/227/ida__003_startupinfo.png)

A l'examen, on constate que cette fonction semble être impliquée dans l'initialisation de la `StartupInfo`structure et la réalisation de certaines vérifications relatives à sa valeur. L' `rep stosq`instruction annule un bloc de mémoire, tandis que les instructions suivantes modifient le contenu des registres et exécutent des sauts conditionnels basés sur les valeurs des registres. Cela ne semble pas être la `main`fonction dans laquelle réside la logique du programme, mais elle contient quelques `call`instructions qui pourraient potentiellement nous conduire à la `main`fonction. Nous étudierons toutes les `call`instructions avant le retour de cette fonction.

Nous devons faire défiler jusqu'au point final de cette fonction et commencer à rechercher `call`les instructions à partir du point le plus bas.

En faisant défiler vers le haut depuis le point final de ce bloc (où la fonction revient), nous observons un appel à un autre sous-programme, , `sub_403250`avant le retour de cette fonction.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_004_intmain.png)

Notre objectif est de parcourir les appels de fonction précédant la sortie du programme afin de localiser la fonction principale, qui pourrait contenir le code initial pour la vérification du registre (détection du bac à sable) dont nous avons été témoins dans le moniteur de processus et les chaînes.

Nous devons maintenant accéder à la fonction `sub_403250`pour étudier son contenu. Pour accéder à cette fonction, il faut positionner le curseur sur l'instruction d'appel ci-dessous :

Code : ida

```
call    sub_403250

```

Nous pouvons cliquer avec le bouton droit sur l'instruction et sélectionner `Jump to Operand`dans le menu contextuel, ou bien, nous pouvons appuyer sur la `Enter`touche. Cette action révélera la fonction démontée pour `sub_403250`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_005_main.png)

Après avoir examiné les instructions, il semble que la fonction interroge le registre pour connaître la valeur associée au `SOFTWARE\\VMware, Inc.\\VMware Tools`chemin et effectue une comparaison pour déterminer si VMWare Tools est installé sur la machine. D'une manière générale, il semble probable qu'il s'agisse de la `main`fonction référencée dans le moniteur de processus et les chaînes.

Nous pouvons observer que la requête du registre est effectuée à l'aide de la fonction `RegOpenKeyExA`, comme indiqué dans l'instruction `call cs:RegOpenKeyExA`du code démonté qui suit :

Code : ida

```
xor     r8d, r8d        ; ulOptions
mov     [rsp+148h+cbData], 100h
mov     [rsp+148h+phkResult], rax ; phkResult
mov     r9d, 20019h     ; samDesired
lea     rdx, aSoftwareVmware ; "SOFTWARE\\VMware, Inc.\\VMware Tools"
mov     rcx, 0FFFFFFFF80000002h ; hKey
call    cs:RegOpenKeyExA

```

Dans le bloc de code ci-dessus, l'instruction finale, `call cs:RegOpenKeyExA`, est vraisemblablement une représentation de l' `RegOpenKeyExA`appel de fonction, précédée de `cs`. La fonction `RegOpenKeyExA`fait partie de l'API du registre Windows et est utilisée pour ouvrir un handle vers une clé de registre spécifiée. Cette fonction permet d'accéder au registre Windows. Le `A`dans le nom de la fonction signifie qu'il s'agit `ANSI version`de la fonction, qui fonctionne sur des chaînes codées ANSI.

Dans `IDA`, `cs`est un registre de segments qui fait généralement référence au segment de code. Lorsque nous cliquons `cs:RegOpenKeyExA`et appuyons sur `Enter`, cette action nous amène à la `.idata`section qui comprend les données liées à l'importation et l'adresse d'importation de la fonction `RegOpenKeyExA`. Dans ce scénario, la `RegOpenKeyExA`fonction est importée depuis une bibliothèque externe (advapi32.dll), avec son adresse stockée dans la `.idata`section pour une utilisation ultérieure.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_winapi.png)

Code : ida

```
.idata:0000000000409370 ; LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
.idata:0000000000409370                 extrn RegOpenKeyExA:qword
.idata:0000000000409370                                         ; CODE XREF: sub_403160+3E↑p
.idata:0000000000409370                                         ; sub_403220+3C↑p
.idata:0000000000409370                                         ; DATA XREF: ...

```

Il ne s'agit pas de l'adresse réelle de la `RegOpenKeyExA`fonction, mais plutôt de l'adresse de l'entrée dans le `IAT (Import Address Table)`for `RegOpenKeyExA`. L'entrée IAT héberge l'adresse qui sera résolue dynamiquement au moment de l'exécution pour pointer vers l'implémentation réelle de la fonction dans la DLL respective (dans ce cas, advapi32.dll).

La ligne `extrn RegOpenKeyExA:qword`indique qu'il `RegOpenKeyExA`s'agit d'un symbole externe à résoudre au moment de l'exécution. Cela avertit l'assembleur que la fonction est définie dans un autre module ou bibliothèque, et l'éditeur de liens gérera la résolution de son adresse pendant le processus de liaison.

[Référence : https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#import-address-table](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#import-address-table)

En réalité, `cs:RegOpenKeyExA`il s'agit d'un moyen d'accéder à l' `IAT`entrée `RegOpenKeyExA`du segment de code à l'aide d'une référence relative. L'adresse réelle de `RegOpenKeyExA`sera résolue et stockée dans l'IAT pendant l'exécution par l'éditeur de liens/chargeur dynamique du système d'exploitation.

Sur la base de la structure globale de cette fonction, nous pouvons conjecturer qu'il s'agit de la `main`fonction possible. Renommons-le `assumed_Main`pour faciliter la mémorisation au cas où nous rencontrerions des références à cette fonction à l'avenir.

* * * * *

Pour renommer une fonction dans `IDA`, il faut procéder comme suit :

-   Positionnez le curseur sur le nom de la fonction ( `sub_403250`) ou sur la ligne contenant la définition de la fonction. Ensuite, appuyez sur la `N`touche du clavier ou cliquez avec le bouton droit et sélectionnez `Rename`dans le menu contextuel.
-   Saisissez le nouveau nom de la fonction et appuyez sur `Enter`.

IDA mettra à jour le nom de la fonction tout au long de la vue de désassemblage et toutes les références à la fonction dans le binaire.

Remarque : Renommer une fonction dans `IDA`ne modifie pas le fichier binaire lui-même. Cela ne fait que modifier la représentation dans `IDA`l'analyse de .

![Image](https://academy.hackthebox.com/storage/modules/227/ida_006_assumed_main.png)

Passons maintenant aux instructions présentes dans ce bloc de code.

Nous pouvons identifier deux appels de fonction émanant de cette fonction ( `sub_401610`et `sub_403110`) avant d'appeler la fonction API Windows `RegOpenKeyExA`. Examinons ces deux éléments avant de passer aux fonctions WINAPI.

Examinons ces fonctions en dirigeant le curseur vers leurs `call`instructions respectives et en appuyant `Enter`pour avoir un aperçu de l'intérieur.

Commencez par examiner le code démonté du premier sous-programme `sub_401610`. Initiez le parcours dans le sous-programme en appuyant `Enter`sur l'instruction d'appel de `sub_401610`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_enter_init_checks_.png)

Nous nous retrouvons dans le premier sous-programme `sub_401610`, qui examine la valeur d'une variable ( `cs:dword_408030`). Si sa valeur est nulle, elle est redéfinie comme un. Il redirige ensuite vers `sub_4015A0`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_007_init_checks.png)

Les instructions suivantes détaillent `sub_401610`. Efforçons-nous d'en comprendre les nuances.

Code : ida

```
sub_401610 proc near

mov     eax, cs:dword_408030
test    eax, eax
jz      short loc_401620

loc_401620:
mov     cs:dword_408030, 1
jmp     sub_4015A0
sub_401610 endp

```

Il démarre en transférant la valeur de la variable `dword_408030`dans le `eax`registre. Il effectue ensuite une `bitwise AND`opération avec `eax`et lui-même, évaluant essentiellement si la valeur est `zero`. Si le résultat de l'instruction de test précédente est `eax`positif `zero`, elle redirige vers `sub_4015A0`. Examinons son code plus en détail.

Code : ida

```
sub_4015A0 proc near

push    rsi
push    rbx
sub     rsp, 28h
mov     rdx, cs:off_405730
mov     rax, [rdx]
mov     ecx, eax
cmp     eax, 0FFFFFFFFh
jz      short loc_4015F0

```

En appuyant `Enter`pendant que le curseur est sur le nom de la fonction `sub_4015A0`, nous naviguons vers le code désassemblé, révélant que la fonction commence en poussant les valeurs des registres `rsi`et `rbx`sur la pile, en préservant les valeurs des registres. Par la suite, il alloue de l'espace sur la pile en soustrayant `28h (40 decimal)`des octets du pointeur de pile ( `rsp`). Il récupère ensuite un pointeur de fonction à partir de l'adresse encapsulée `off_405730`et le stocke dans le `rax`registre.

Essentiellement, ils semblent exécuter des contrôles d'initialisation et des opérations liées aux pointeurs de fonction avant que le programme ne procède à l'appel du deuxième sous-programme `sub_403110`et de la fonction WINAPI pour les opérations de registre. Ce n'est pas la fonction principale qui héberge la logique du programme, nous allons donc examiner d'autres appels de fonction pour identifier la `main`fonction.

Nous pouvons renommer cette fonction comme `initCheck`pour notre souvenir en appuyant `N`et en tapant le nouveau nom de la fonction.

À ce stade, soit nous appuyons sur la `Esc`touche, soit nous sélectionnons le `Jump Back`bouton dans la barre d'outils pour revenir au deuxième sous-programme `sub_403110`et explorer son fonctionnement interne.

Une fois que nous sommes revenus à la fonction précédente ( `assumed_Main`), nous devons positionner le curseur sur l' `call sub_403110`instruction et appuyer sur `Enter`.

![Image](https://academy.hackthebox.com/storage/modules/227/correction.png)

Cette transition nous amène dans le code démonté de cette fonction. Examinons-le pour déterminer son fonctionnement.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_008_shellexecutea.png)

Les variables `Parameters`, `File`et `Operation`sont des variables chaîne rangées dans la `.rdata`section de l'exécutable. Les `lea`instructions sont utilisées pour obtenir les adresses mémoire de ces chaînes, qui sont ensuite transmises comme arguments à la `ShellExecuteA`fonction. Ce bloc de code est responsable d'une `sleep`durée de `5 seconds`. Ensuite, il revient à la fonction précédente. Après avoir compris le code, nous pouvons renommer cette fonction comme `pingSleep`en faisant un clic droit et en choisissant renommer.

Maintenant que nous avons rencontré quelques références pour les fonctions de l'API Windows, expliquons comment les fonctions WINAPI sont interprétées dans le code désassemblé.

* * * * *

Après avoir étudié les opérations dans les deux appels de fonction ( `sub_401610`et `sub_403110`) de cette fonction et avant d'invoquer la fonction API Windows `RegOpenKeyExA`, inspectons les appels effectués à la fonction WINAPI `RegOpenKeyExA`. Dans cette `IDA`vue de désassemblage, les arguments passés à l'appel de fonction WINAPI sont représentés au-dessus de l' `call`instruction. Cette convention standard dans les désassembleurs offre une représentation claire de l'appel de fonction avec ses arguments correspondants.

La fonction API Windows, `RegOpenKeyExA`, est utilisée ici pour déverrouiller une clé de registre. La syntaxe de cette fonction, selon la documentation Microsoft, est présentée ci-dessous.

Code : ida

```
LSTATUS RegOpenKeyExA(
  [in]           HKEY   hKey,
  [in, optional] LPCSTR lpSubKey,
  [in]           DWORD  ulOptions,
  [in]           REGSAM samDesired,
  [out]          PHKEY  phkResult
);

```

![Image](https://academy.hackthebox.com/storage/modules/227/msdn_001_regopenkey.png)

Déconstruisons le code de cette fonction tel qu'il apparaît dans la `IDA`vue démontée.

Code : ida

```
lea     rax, [rsp+148h+hKey]      ; Calculate the address of hKey
xor     r8d, r8d                  ; Clear r8d register (ulOptions)
mov     [rsp+148h+phkResult], rax ; Store the calculated address of hKey in phkResult
mov     r9d, 20019h               ; Set samDesired to 0x20019h (which is KEY_READ in MS-DOCS)
lea     rdx, aSoftwareVmware      ; Load address of string "SOFTWARE\\VMware, Inc.\\VMware Tools"
mov     rcx, 0FFFFFFFF80000002h   ; Set hKey to 0xFFFFFFFF80000002h (HKEY_LOCAL_MACHINE)
call    cs:RegOpenKeyExA          ; Call the RegOpenKeyExA function
test    eax, eax                  ; Check the return value
jnz     short loc_40330F          ; Jump if the return value is not zero (error condition)

```

L' `lea`instruction calcule l'adresse de la `hKey`variable, probablement un handle vers une clé de registre. Ensuite, `mov rcx, 0FFFFFFFF80000002h`pousse `HKEY_LOCAL_MACHINE`comme premier argument ( `rcx`) vers la fonction. L' `lea rdx, aSoftwareVmware`instruction utilise l' `load effective address (LEA)`opération pour calculer l'adresse effective de l'emplacement mémoire stockant la chaîne `Software\\VMware, Inc.\\VMware Tools`. Cette adresse calculée est ensuite stockée dans le `rdx`registre, deuxième argument de la fonction.

Le troisième argument de cette fonction est transmis au `r8d`registre via l'instruction `xor r8d, r8d`qui vide le `r8d`registre en implémentant une `XOR`opération avec lui-même, le remettant effectivement à zéro. Dans le contexte de ce code, cela indique que le troisième argument ( `ulOptions`) passé à la `RegOpenKeyExA`fonction porte la valeur `0`.

Le quatrième argument est `mov r9d, 20019h`, correspondant à `KEY_READ`dans [MS-DOCS](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-key-security-and-access-rights) .

Le cinquième argument, `phkResult`, se trouve sur la pile. En ajoutant `rsp+148h`au pointeur de la pile de base `rsp`, le code accède à l'emplacement mémoire de la pile où `phkResult`réside le paramètre. L' `mov [rsp+148h+phkResult], rax`instruction duplique la valeur de `rax`(qui contient l'adresse de `hKey`) vers l'emplacement mémoire pointé par `phkResult`, stockant essentiellement l'adresse de `hKey`in `phkResult`(qui est transmise à la fonction suivante comme premier argument).

À partir de maintenant, chaque fois que nous tombons sur une référence à une fonction WINAPI dans le code, nous recourrons à la documentation Microsoft de cette fonction pour comprendre sa syntaxe, ses paramètres et la valeur de retour. Cela nous aidera à comprendre les valeurs probables dans les registres lorsque ces fonctions sont invoquées.

Si nous faisons défiler la vue graphique, nous rencontrons la fonction WINAPI suivante `RegQueryValueExA`qui récupère le type et les données pour le nom de valeur spécifié associé à une clé de registre ouverte. Les données clés sont comparées et en cas de correspondance, une boîte de message indiquant `Sandbox Detected`s'affiche. S'il ne correspond pas, il redirige vers un autre sous-programme `sub_402EA0`. Nous corrigerons également cette détection de sandbox dans le débogueur ultérieurement. L'image ci-dessous présente le déroulement global de cette opération.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_009_after_sandbox.png)

Appuyons `Enter`sur l'instruction d'appel à venir de la fonction `sub_402EA0`pour nous permettre d'examiner ce sous-programme et de comprendre ses opérations.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_010_getaddrinfo.png)

En appuyant sur `Enter`, nous découvrons sa fonctionnalité. Ce sous-programme semble exécuter des opérations liées au réseau à l'aide du `Windows Sockets API (Winsock)`. Il appelle d'abord la `WSAStartup`fonction pour configurer la `Winsock`bibliothèque, puis il appelle la `WSAAPI`fonction `getaddrinfo`qui est utilisée pour récupérer les informations d'adresse pour le nom de nœud spécifié ( `pNodeName`) en fonction des indications fournies `pHints`. Le sous-programme vérifie le succès de la résolution d'adresse à l'aide de la `getaddrinfo`fonction.

Si la `getaddrinfo`fonction renvoie une valeur de retour de `zero`(indiquant le succès), cela implique que l'adresse a été résolue avec succès en adresse IP. Suite à cet événement, en cas de succès, la séquence passe à une MessageBox qui affiche `Sandbox detected`. Sinon, il dirige le flux vers le sous-programme `sub_402D00`.

Par la suite, il invite à l'invocation de la `WSACleanup`fonction. Cette action lance le nettoyage des ressources liées à `Winsock`, que le processus de résolution d'adresse ait réussi ou échoué. Par souci de clarté, nous baptiserons cette fonction `DomainSandboxCheck`.

IOC possible : Veuillez noter le nom de domaine `iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea[.]com`comme composant des `IOC`s potentiels.

Pour explorer les conséquences du contournement de la vérification du bac à sable, nous examinerons le sous-programme `sub_402D00`. Nous pouvons examiner ce sous-programme en cliquant `Enter`sur l'instruction suivante `call`liée à la `sub_402D00`fonction. Une image ci-jointe affiche le code démonté pour cette fonction.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_011_func_check.png)

Cette fonction réserve d'abord de l'espace sur la pile pour les variables locales avant d'appeler `sub_402C20`une fonction distincte. La sortie de cette fonction est ensuite stockée dans le `eax`registre. En fonction des résultats dérivés de la `sub_402C20`fonction, la séquence renvoie ( `retn`) ou passe à `sub_402D20`.

Par conséquent, nous sélectionnerons la première fonction en surbrillance, `sub_402C20`, en appuyant sur `Enter`pour examiner ses instructions. Après une analyse approfondie de `sub_402C20`, nous reviendrons sur ce bloc pour évaluer la deuxième fonction mise en évidence, `sub_402D20`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_012_socketconnect.png)

En appuyant sur `Enter`, nous sommes accueillis avec ses instructions, comme le montre l'image ci-dessus. Cette fonction lance la `Winsock`bibliothèque, génère un socket et se connecte à l'adresse IP `45.33.32.156`via le port `31337`. Il évalue la valeur de retour ( `eax`) pour vérifier si la connexion a réussi. Cependant, il y a une différence ; après l'invocation de la fonction, l'instruction `inc eax`incrémente la `eax`valeur du registre de `1`. Suite à l' `inc eax`instruction, le code évalue l'intérêt de `eax`l'utilisation de l' `jnz (jump if not zero)`instruction.

En cas d'échec de la connexion au port et à l'adresse IP susmentionnés, cette fonction doit renvoyer `-1`, comme spécifié dans la documentation.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_013_socketerror.png)

Code : ida

```
call    cs:connect
inc     eax
jnz     short loc_402CD0

```

Étant donné que cela `eax`est incrémenté par `1`l'appel post-fonction, cela devrait être réduit à `0`. Par conséquent, le `MessageBox`sera imprimé `Sandbox detected`. Cela implique que la fonction examine l'état de la connexion Internet.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_014_jump_check.png)

Si, en revanche, la connexion réussit, elle produira une `non-zero`valeur, invitant le code à passer à `loc_402CD0`. Cet emplacement héberge un appel à une autre fonction, `sub_402F40`. Avec une compréhension claire des opérations de cette fonction, nous la renommerons `InternetSandboxCheck`.

IOC possible : Pensez à noter cette adresse IP `45.33.32.156`et ce port `31337`comme composants d' `IOC`e-mails potentiels.

Ensuite, nous passerons à la fonction `sub_402F40`pour déchiffrer ses opérations. Nous pouvons le faire en cliquant avec le bouton droit et en sélectionnant `Jump to Operand`, ou en appuyant `Enter`sur son `call`instruction.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_015_svchost.png)

Cette fonction fait appel à la `getenv`fonction (en `rcx`faisant office de passeur d'argument pour `TEMP`) et enregistre son résultat dans le `eax`registre. Cette action récupère la `TEMP`valeur de la variable d'environnement.

Code : ida

```
lea     rcx, VarName    ; "TEMP"
call    getenv

```

Pour vérifier la sortie, nous pouvons utiliser PowerShell pour imprimer la `TEMP`valeur de la variable d'environnement.

```
PS C:\> Get-ChildItem env:TEMP

Name                           Value
----                           -----
TEMP                           C:\Users\htb-student\AppData\Local\Temp

```

Il utilise ensuite la `sprintf`fonction pour ajouter le `TEMP`chemin obtenu à la chaîne `svchost.exe`, ce qui donne un chemin de fichier complet. Par la suite, la `GetComputerNameA`fonction est appelée pour récupérer le nom de l'ordinateur, qui est ensuite stocké dans un tampon.

Si le nom de l'ordinateur est inexistant, il passe directement à l'étiquette `loc_4030F8`(qui contient les instructions de retour). À l'inverse, si le nom de l'ordinateur n'est pas vide ( `non-zero`valeur), le code passe à l'instruction suivante telle qu'affichée sur le côté gauche de l'image.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_016_svchost_download.png)

Dans les instructions suivantes, nous trouvons un appel à la fonction `sub_403220`. Nous pouvons y accéder en double-cliquant sur le nom de la fonction.

Le côté gauche de l'image ci-jointe affiche la fonction `sub_403220`, qui formate une chaîne contenant une `user-agent`valeur personnalisée avec la chaîne `Windows-Update/7.6.7600.256 %s`. L' `%s`espace réservé est remplacé par le nom d'ordinateur précédemment obtenu, qui est transmis à cette fonction dans le `rcx`registre.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_016_svchost_temp.png)

Maintenant, la valeur complète est `Windows-Update/7.6.7600.256 HOSTNAME`, où `HOSTNAME`est le résultat de `GetComputerNameA`(le nom de l'ordinateur).

Il est crucial de noter cette coutume unique `user-agent`, selon laquelle le nom d'hôte est également transmis dans la requête lorsque le logiciel malveillant établit une connexion réseau.

De retour à la fonction précédente, il appelle ensuite la `InternetOpenA`fonction WINAPI pour démarrer une session d'accès Internet et configurer les paramètres de la `InternetOpenUrlA`fonction. Il procède ensuite à l'appel de ce dernier pour ouvrir l'URL `http://ms-windows-update.com/svchost.exe`.

IOC possible : notez cette URL `http[:]//ms-windows-update[.]com/svchost[.]exe`comme potentielle `IOC`. Le malware télécharge un exécutable supplémentaire à partir de cet emplacement.

Si l'URL s'ouvre avec succès, le code passe à l'étiquette `loc_40301E`. Examinons les instructions `loc_40301E`en double-cliquant dessus.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_017_createfile.png)

A l'ouverture de la fonction, on observe un appel à la fonction API Windows `CreateFileA`, qui permet de générer un fichier sur le système local, désignant le chemin du fichier précédemment obtenu.

Le code entre ensuite dans une boucle, appelant à plusieurs reprises la `InternetReadFile`fonction pour extraire les données de l'URL ouverte `http[:]//ms-windows-update[.]com/svchost[.]exe`. Si l'opération de lecture des données réussit, le code avance pour écrire les données reçues dans le fichier créé ( `svchost.exe`situé dans le `TEMP`répertoire) à l'aide de la `WriteFile`fonction.

Notez cette technique unique, où le malware télécharge et dépose un fichier exécutable `svchost.exe`dans le `temp`répertoire.

La boucle susmentionnée est illustrée dans l'image ci-dessous.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_018_readfile.png)

Après l'opération d'écriture des données, le code revient en arrière pour lire davantage de données jusqu'à ce que la `InternetReadFile`fonction renvoie une valeur indiquant la fin du flux de données. Une fois toutes les données lues et écrites, le fichier ouvert et les identifiants Internet sont fermés à l'aide des fonctions appropriées ( `CloseHandle`et `InternetCloseHandle`). Par la suite, le code saute vers `loc_4030D3`, où il fait appel à la fonction `sub_403190`.

Nous double-cliquerons sur `sub_403190`pour dévoiler son contenu.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_018_writefile.png)

La fonction `sub_403190`est maintenant exposée, révélant une série d'appels WINAPI liés aux modifications du registre, tels que `RegOpenKeyExA`et `RegSetValueExA`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_19_reg.png)

Il semble que cette fonction place le fichier ( `svchost.exe`situé dans le `TEMP`répertoire) dans le chemin de la clé de registre `SOFTWARE\Microsoft\Windows\CurrentVersion\Run`avec la valeur name `WindowsUpdater`, puis scelle la clé de registre. Cette technique est fréquemment utilisée par les logiciels malveillants et les applications légitimes pour maintenir leur emprise sur le système lors des redémarrages, garantissant ainsi un fonctionnement automatique à chaque lancement du système ou à chaque fois qu'un utilisateur se connecte. Nous avons pris la liberté de renommer cette fonction en pour le `IDA`plaisir `persistence_registry`. de clarté.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_020_regvalue.png)

IOC possible : Mettez en évidence cette technique dans laquelle le malware modifie le registre pour obtenir la persistance. Pour ce faire, il ajoute une entrée `svchost.exe`sous le `WindowsUpdater`nom dans la `SOFTWARE\Microsoft\Windows\CurrentVersion\Run`clé de registre.

Lors de l'établissement du registre, il lance une autre fonction, `sub_403150`, qui active le fichier déposé `svchost.exe`et y canalise un argument. Une recherche rudimentaire sur Google suggère que cet argument pourrait potentiellement être un `Bitcoin wallet address`. Ainsi, il est raisonnable de postuler que l'exécutable abandonné pourrait être un mineur de pièces.

En rembobinant nos étapes et en inspectant systématiquement les fonctions, nous pouvons identifier toutes les fonctions résiduelles que nous n'avons pas encore examinées. La `Esc`clé ou le `Jump Back`bouton dans la barre d'outils facilite ce suivi inverse.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_021_pendingfunction.png)

Après avoir remonté le code analysé, nous arrivons à ce bloc, où un sous-programme `sub_402D20`est en attente d'analyse. Alors double-cliquons pour l'ouvrir et voir ce qu'il contient.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_022_notepad.png)

À l'ouverture du sous-programme, il est clair qu'il configure les paramètres nécessaires pour que la `CreateProcessA`fonction génère un nouveau processus. Il procède ensuite au lancement d'un nouveau processus, `notepad.exe`, situé dans l' `C:\Windows\System32`annuaire.

Voici la syntaxe de la fonction CreateProcessA.

Code : ida

```
BOOL CreateProcessA(
  [in, optional]      LPCSTR                lpApplicationName,
  [in, out, optional] LPSTR                 lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCSTR                lpCurrentDirectory,
  [in]                LPSTARTUPINFOA        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);

```

Comme `rdx`observé dans le code, nous voyons que le deuxième argument de cette fonction est identifié comme `C:\\Windows\\System32\\notepad.exe`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_createProcess.png)

Nous notons dans la `CreateProcessA`documentation de la fonction qu'une `nonzero`valeur de retour indique une exécution réussie de la fonction. Par conséquent, en cas de succès, il ne passera pas au `loc_402E89`bloc d'instructions suivant mais passera au bloc d'instructions suivant.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_023_procInj.png)

Le bloc d'instructions suivant fait allusion à un type courant d'injection de processus, dans lequel `shellcode`est inséré dans le processus nouvellement créé à l'aide des fonctions `VirtualAllocEx`, `WriteProcessMemory`et `CreateRemoteThread`.

Décryptons l'injection de processus en fonction de nos observations du code.

Un nouveau `notepad.exe`processus est fabriqué via la `CreateProcessA`fonction. Ensuite, la mémoire est allouée au sein de ce processus à l'aide de `VirtualAllocEx`. Le `shellcode`est ensuite inscrit dans la mémoire allouée du processus distant `notepad.exe`à l'aide de la fonction WINAPI `WriteProcessMemory`. Enfin, un thread distant est établi dans `notepad.exe`, initiant l' `shellcode`exécution via la `CreateRemoteThread`fonction.

Si l'injection est triomphante, une boîte de message apparaît, déclarant `Connection sent to C2`. A l'inverse, un message d'erreur apparaît en cas de panne.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_023_conn_sent.png)

Par souci de simplicité, renommez la fonction `sub_402D20`en `process_Injection`.

Au début de cette fonction, on peut repérer une adresse inconnue `unk_405057`dont l'adresse effective est chargée dans le `rsi`registre via l'instruction `lea rsi, unk_405057`. Exécuté avant l'appel des fonctions WINAPI pour l'injection de processus, la raison du chargement de l'adresse effective dans `rsi`peut être multiple - elle peut fonctionner comme un pointeur d'accès aux données ou comme un argument d'appel de fonction. Il est cependant possible que cette adresse abrite du potentiel `shellcode`. Nous vérifierons cela lorsque `debugging`ces WINAPI fonctionneront en utilisant un débogueur comme `x64dbg`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_024_shellcode.png)

Après avoir analysé et renommé cette fonction d'injection de processus, nous continuerons à retracer nos étapes jusqu'aux fonctions précédentes pour nous assurer qu'aucune fonction n'a été négligée.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_025_backtomain.png)

`IDA`propose également une fonctionnalité qui visualise le flux d'exécution entre les fonctions dans un exécutable via un fichier `call flow graph`. Ce puissant outil visuel aide les analystes à naviguer et à comprendre le flux de contrôle et les interactions entre les fonctions.

Voici comment générer et examiner le graphique pour identifier les liens entre les différentes fonctions :

-   Passez à la vue de démontage.
-   Localisez le `View`menu en haut de l' `IDA`interface.
-   Passez la souris sur l' `Graphs`option.
-   Dans le sous-menu, choisissez `Function calls`.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_graph_flow.png)

`IDA`va ensuite forger le graphique de flux des appels de fonctions pour toutes les fonctions du binaire et le présentera dans une nouvelle fenêtre. Ce graphique offre un aperçu des appels effectués entre les différentes fonctions du programme, nous permettant d'examiner le flux de contrôle et les dépendances entre les fonctions. Un exemple de la façon dont ce graphique apparaît est présenté dans la capture d'écran ci-dessous.

![Image](https://academy.hackthebox.com/storage/modules/227/ida_026_callflowgraph.png)

Contrairement à l'affichage du graphique de relations pour tous les appels de fonction, nous pouvons également nous concentrer sur des fonctions spécifiques. Pour générer le graphique de référence pour le flux d'appels de fonction lié à une fonction spécifique, ces étapes peuvent être suivies.

-   Accédez à la fonction dont nous souhaitons examiner le graphique de flux d'appels de fonction.
-   Pour ouvrir la fonction dans la vue de démontage, double-cliquez sur le nom de la fonction ou appuyez sur `Enter`.
-   Dans la vue de démontage, cliquez avec le bouton droit n'importe où et optez pour ou `Xrefs graph to...`, `Xrefs graph from...`selon que nous souhaitons observer les appels de fonction effectués par la fonction sélectionnée ou les appels de fonction menant à la fonction sélectionnée.
-   `IDA`créera le graphique de flux des appels de fonction et l'affichera dans une nouvelle fenêtre.

Pour l'avenir, nous aborderons le débogage dans la section suivante. Là, nous lancerons l'exécutable dans un débogueur, établirons des points d'arrêt sur les instructions requises et sélectionnerons les fonctions WINAPI critiques. Cette stratégie nous permet de comprendre et de gérer le flux d'exécution en temps réel pendant le fonctionnement du programme.