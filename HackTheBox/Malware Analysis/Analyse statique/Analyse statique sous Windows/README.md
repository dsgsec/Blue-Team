Analyse statique sous Windows
=============================

Dans ce segment, nous nous concentrerons sur la reproduction de certaines des tâches d'analyse statique que nous avons effectuées sur une machine Linux, mais cette fois, nous utiliserons une machine Windows.

Naviguons maintenant vers le bas de cette section et cliquons sur "Cliquez ici pour générer le système cible !". Ensuite, passons à RDP dans l'adresse IP cible en utilisant les informations d'identification fournies. La grande majorité des actions/commandes couvertes de ce point à la fin de cette section peuvent être répliquées dans la cible, offrant ainsi une compréhension plus complète des sujets présentés.

```
dsgsec@htb[/htb]$ xfreerdp /u:htb-student /p:'HTB_@cademy_stdnt!' /v:[Target IP] /dynamic-resolution

```

Identification du type de fichier
---------------------------------

Notre première étape à ce stade est de vérifier les informations rudimentaires sur le spécimen de malware afin de jeter les bases de notre enquête. Étant donné que les extensions de fichiers peuvent être manipulées et modifiées, notre tâche consiste à concevoir une méthode permettant d'identifier le type de fichier réel que nous rencontrons. L'établissement du type de fichier joue un rôle essentiel dans l'analyse statique, garantissant que les procédures que nous appliquons sont appropriées et que les résultats obtenus sont exacts.

Utilisons à titre d'illustration un malware basé sur Windows nommé `Ransomware.wannacry.exe`résidant dans le `/home/htb-student/Samples/MalwareAnalysis`répertoire de la cible de cette section.

Nous pouvons utiliser une solution comme `CFF Explorer`(disponible sur `C:\Tools\Explorer Suite`) pour vérifier le type de fichier de ce malware comme suit.

![Image](https://academy.hackthebox.com/storage/modules/227/filetype1.png)

Sur un système Windows, la présence de la chaîne ASCII `MZ`(en hexadécimal : `4D 5A`) au début d'un fichier (appelé « nombre magique ») désigne un fichier exécutable. `MZ`signifie Mark Zbikowski, un architecte clé de MS-DOS.

Empreinte digitale des logiciels malveillants
---------------------------------------------

À cette étape, notre mission est de créer un identifiant unique pour l'échantillon de malware. Cela prend généralement la forme d'un hachage cryptographique : MD5, SHA1 ou SHA256.

Les empreintes digitales sont utilisées à de nombreuses fins, notamment :

-   Identification et suivi des échantillons de logiciels malveillants
-   Analyser un système entier pour détecter la présence de logiciels malveillants identiques
-   Confirmation des rencontres précédentes et analyses du même malware
-   Partage avec les parties prenantes en tant qu'IoC (Indicators of Compromise) ou dans le cadre de rapports de renseignements sur les menaces

À titre d'illustration, pour vérifier le hachage du fichier MD5 du malware mentionné ci-dessus, nous pouvons utiliser l' `Get-FileHash`applet de commande PowerShell comme suit.

```
PS C:\Users\htb-student> Get-FileHash -Algorithm MD5 C:\Samples\MalwareAnalysis\Ransomware.wannacry.exe

Algorithm       Hash                                                                   Path
---------       ----                                                                   ----
MD5             DB349B97C37D22F5EA1D1841E3C89EB4                                       C:\Samples\MalwareAnalysis\Ra...

```

Pour vérifier le hachage du fichier SHA256 du malware mentionné ci-dessus, la commande serait la suivante.

```
PS C:\Users\htb-student> Get-FileHash -Algorithm SHA256 C:\Samples\MalwareAnalysis\Ransomware.wannacry.exe

Algorithm       Hash                                                                   Path
---------       ----                                                                   ----
SHA256          24D004A104D4D54034DBCFFC2A4B19A11F39008A575AA614EA04703480B1022C       C:\Samples\MalwareAnalysis\Ra...

```

Recherche de hachage de fichier
-------------------------------

L'étape suivante consiste à vérifier le hachage de fichier produit à l'étape précédente par rapport aux scanners de logiciels malveillants en ligne et aux bacs à sable tels que le bac à sable Cuckoo. Par exemple, VirusTotal, un moteur d'analyse des logiciels malveillants en ligne, qui collabore avec divers fournisseurs d'antivirus, nous permet de rechercher le hachage du fichier. Cette étape nous aide à comparer nos résultats avec les connaissances existantes sur l'échantillon de malware.

L'image suivante affiche les résultats de [VirusTotal](https://www.virustotal.com/gui/home/search) après la soumission du hachage du fichier SHA256 du malware susmentionné.

![Image](https://academy.hackthebox.com/storage/modules/227/virustotal_scan.png)

Même si un hachage de fichier tel que MD5, SHA1 ou SHA256 est utile pour identifier des échantillons identiques portant des noms disparates, il ne suffit pas à identifier des échantillons de logiciels malveillants similaires. Cela est principalement dû au fait qu'un auteur de malware peut modifier la valeur de hachage du fichier en apportant des modifications mineures au code et en le recompilant.

Néanmoins, il existe des techniques qui peuvent aider à identifier des échantillons similaires :

### Importer le hachage (IMPHASH)

`IMPHASH`, abréviation de « Import Hash », est un hachage cryptographique calculé à partir des fonctions d'importation d'un fichier Windows Portable Executable (PE). Son algorithme fonctionne en convertissant d'abord tous les noms de fonctions importés en minuscules. Ensuite, les noms de DLL et les noms de fonctions sont fusionnés et classés par ordre alphabétique. Enfin, un hachage MD5 est généré à partir de la chaîne résultante. Par conséquent, deux fichiers PE avec des fonctions d'importation identiques, dans la même séquence, partageront une `IMPHASH`valeur.

Nous pouvons le trouver `IMPHASH`dans l' `Details`onglet des résultats VirusTotal.

![Image](https://academy.hackthebox.com/storage/modules/227/imphash_vt1.png)

Notez que nous pouvons également utiliser le module Python [pefile](https://pypi.org/project/pefile/) pour calculer le `IMPHASH`fichier d'un fichier comme suit.

Code : python

```
import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = pe.get_imphash()

print(imphash)

```

Pour vérifier le `IMPHASH`malware WannaCry mentionné ci-dessus, la commande serait la suivante. `imphash_calc.py`contient le code Python ci-dessus.

```
C:\Scripts> python imphash_calc.py C:\Samples\MalwareAnalysis\Ransomware.wannacry.exe
9ecee117164e0b870a53dd187cdd7174

```

### Hachage flou (SSDEEP)

`Fuzzy Hashing (SSDEEP)`, également appelé hachage par morceaux déclenché par le contexte (CTPH), est une technique de hachage conçue pour calculer une valeur de hachage indicative de la similarité du contenu entre deux fichiers. Cette technique décompose un fichier en blocs plus petits de taille fixe et calcule un hachage pour chaque bloc. Les valeurs de hachage résultantes sont ensuite consolidées pour générer le hachage flou final.

L' `SSDEEP`algorithme accorde plus de poids aux séquences plus longues de blocs communs, ce qui le rend très efficace pour identifier les fichiers qui ont subi des modifications mineures ou qui sont similaires mais non identiques, comme différentes variantes d'un échantillon malveillant.

On peut retrouver le `SSDEEP`hash d'un malware dans l' `Details`onglet des résultats VirusTotal.

On peut également utiliser l' `ssdeep`outil (disponible sur `C:\Tools\ssdeep-2.14.1`) pour calculer le `SSDEEP`hachage d'un fichier. Pour vérifier le `SSDEEP`hachage du malware WannaCry mentionné ci-dessus, la commande serait la suivante.

```
C:\Tools\ssdeep-2.14.1> ssdeep.exe C:\Samples\MalwareAnalysis\Ransomware.wannacry.exe
ssdeep,1.1--blocksize:hash:hash,filename
98304:wDqPoBhz1aRxcSUDk36SAEdhvxWa9P593R8yAVp2g3R:wDqPe1Cxcxk3ZAEUadzR8yc4gB,"C:\Samples\MalwareAnalysis\Ransomware.wannacry.exe"

```

![Image](https://academy.hackthebox.com/storage/modules/227/win_ssdeep.png)

### Hachage de section (hachage de sections PE)

`Section hashing`, (hachage des sections PE) est une technique puissante qui permet aux analystes d'identifier les sections d'un fichier Portable Executable (PE) qui ont été modifiées. Cela peut être particulièrement utile pour identifier des variations mineures dans des échantillons de logiciels malveillants, une tactique courante utilisée par les attaquants pour échapper à la détection.

La `Section Hashing`technique fonctionne en calculant le hachage cryptographique de chacune de ces sections. Lors de la comparaison de deux fichiers PE, si le hachage des sections correspondantes dans les deux fichiers correspond, cela suggère que la section particulière n'a pas été modifiée entre les deux versions du fichier.

En appliquant `section hashing`, les analystes de sécurité peuvent identifier les parties d'un fichier PE qui ont été falsifiées ou modifiées. Cela peut aider à identifier des échantillons de logiciels malveillants similaires, même s'ils ont été légèrement modifiés pour échapper aux méthodes de détection traditionnelles basées sur les signatures.

Des outils tels que `pefile`Python peuvent être utilisés pour effectuer `section hashing`. En Python, par exemple, vous pouvez utiliser le module pefile pour accéder et hacher les données dans des sections individuelles d'un fichier PE comme suit.

Code : python

```
import sys
import pefile
pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
for section in pe.sections:
    print (section.Name, "MD5 hash:", section.get_hash_md5())
    print (section.Name, "SHA256 hash:", section.get_hash_sha256())

```

N'oubliez pas que même s'il `section hashing`s'agit d'une technique puissante, elle n'est pas infaillible. Les auteurs de logiciels malveillants peuvent recourir à des tactiques telles que l'obscurcissement des noms de section ou la génération dynamique de noms de section pour tenter de contourner ce type d'analyse.

À titre d'illustration, pour vérifier le hachage du fichier MD5 du malware mentionné ci-dessus, nous pouvons utiliser `pestudio`(disponible sur `C:\Tools\pestudio\pestudio`) comme suit.

![Image](https://academy.hackthebox.com/storage/modules/227/win_section_hashing.png)

Analyse des chaînes
-------------------

Dans cette phase, notre objectif est d'extraire des chaînes (ASCII & Unicode) d'un binaire. Les chaînes peuvent fournir des indices et des informations précieuses sur les fonctionnalités du malware. Parfois, nous pouvons découvrir des chaînes intégrées uniques dans un échantillon de malware, telles que :

-   Noms de fichiers intégrés (par exemple, fichiers supprimés)
-   Adresses IP ou noms de domaine
-   Chemins ou clés de registre
-   Fonctions de l'API Windows
-   Arguments de ligne de commande
-   Informations uniques pouvant faire allusion à un acteur menaçant particulier

Le `strings`binaire Windows `Sysinternals`peut être déployé pour afficher les chaînes contenues dans un malware. Par exemple, la commande ci-dessous révélera les chaînes d'un exemple de ransomware nommé `dharma_sample.exe`résidant dans le `C:\Samples\MalwareAnalysis`répertoire de la cible de cette section.

```
C:\Users\htb-student> strings C:\Samples\MalwareAnalysis\dharma_sample.exe

Strings v2.54 - Search for ANSI and Unicode strings in binary images.
Copyright (C) 1999-2021 Mark Russinovich
Sysinternals - www.sysinternals.com

!This program cannot be run in DOS mode.
gaT
Rich
.text
`.rdata
@.data
HQh
9A s
9A$v
---SNIP---
GetProcAddress
LoadLibraryA
WaitForSingleObject
InitializeCriticalSectionAndSpinCount
LeaveCriticalSection
GetLastError
EnterCriticalSection
ReleaseMutex
CloseHandle
KERNEL32.dll
RSDS%~m
#ka
C:\crysis\Release\PDB\payload.pdb
---SNIP---

```

Parfois, l'analyse de chaînes peut faciliter l'association d'un échantillon de malware à un groupe de menaces spécifique si des similitudes significatives sont identifiées. Par [exemple](https://thedfirreport.com/2020/06/16/the-little-ransomware-that-couldnt-dharma/) , dans le lien fourni, une chaîne contenant un chemin PDB a été utilisée pour relier l'échantillon de malware à la famille de ransomwares Dharma/Crysis.

![Image](https://academy.hackthebox.com/storage/modules/227/dharma.png)

* * * * *

Il convient de noter que l' `FLOSS`outil est également disponible pour les systèmes d'exploitation Windows.

La commande ci-dessous révélera les chaînes d'un exemple de malware nommé `shell.exe`résidant dans le `C:\Samples\MalwareAnalysis`répertoire de la cible de cette section.

```
C:\Samples\MalwareAnalysis> floss shell.exe
INFO: floss: extracting static strings...
finding decoding function features: 100%|████████████████████████████████████████████| 85/85 [00:00<00:00, 1361.51 functions/s, skipped 0 library functions]
INFO: floss.stackstrings: extracting stackstrings from 56 functions
INFO: floss.results: AQAPRQVH1
INFO: floss.results: JJM1
INFO: floss.results: RAQH
INFO: floss.results: AXAX^YZAXAYAZH
INFO: floss.results: XAYZH
INFO: floss.results: ws232
extracting stackstrings: 100%|██████████████████████████████████████████████████████████████████████████████████████| 56/56 [00:00<00:00, 81.46 functions/s]
INFO: floss.tightstrings: extracting tightstrings from 4 functions...
extracting tightstrings from function 0x402a90: 100%|█████████████████████████████████████████████████████████████████| 4/4 [00:00<00:00, 25.59 functions/s]
INFO: floss.string_decoder: decoding strings
emulating function 0x402a90 (call 1/1): 100%|███████████████████████████████████████████████████████████████████████| 22/22 [00:14<00:00,  1.51 functions/s]
INFO: floss: finished execution after 25.20 seconds

FLARE FLOSS RESULTS (version v2.3.0-0-g037fc4b)

+------------------------+------------------------------------------------------------------------------------+
| file path              | shell.exe                                                                          |
| extracted strings      |                                                                                    |
|  static strings        | 254                                                                                |
|  stack strings         | 6                                                                                  |
|  tight strings         | 0                                                                                  |
|  decoded strings       | 0                                                                                  |
+------------------------+------------------------------------------------------------------------------------+

 ──────────────────────
  FLOSS STATIC STRINGS
 ──────────────────────

+-----------------------------------+
| FLOSS STATIC STRINGS: ASCII (254) |
+-----------------------------------+

!This program cannot be run in DOS mode.
.text
P`.data
.rdata
`@.pdata
0@.xdata
0@.bss
.idata
.CRT
.tls
8MZu
HcP<H
D$ H
AUATUWVSH
D$ L
---SNIP---
C:\Windows\System32\notepad.exe
Message
Connection sent to C2
[-] Error code is : %lu
AQAPRQVH1
JJM1
RAQH
AXAX^YZAXAYAZH
XAYZH
ws2_32
PPM1
APAPH
WWWM1
VPAPAPAPI
Windows-Update/7.6.7600.256 %s
1Lbcfr7sAHTD9CgdQo3HTMTkV8LK4ZnX71
open
SOFTWARE\Microsoft\Windows\CurrentVersion\Run
WindowsUpdater
---SNIP---
TEMP
svchost.exe
%s\%s
http://ms-windows-update.com/svchost.exe
45.33.32.156
Sandbox detected
iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com
SOFTWARE\VMware, Inc.\VMware Tools
InstallPath
C:\Program Files\VMware\VMware Tools\
Failed to open the registry key.
Unknown error
Argument domain error (DOMAIN)
Overflow range error (OVERFLOW)
Partial loss of significance (PLOSS)
Total loss of significance (TLOSS)
The result is too small to be represented (UNDERFLOW)
Argument singularity (SIGN)
_matherr(): %s in %s(%g, %g)  (retval=%g)
Mingw-w64 runtime failure:
Address %p has no image-section
  VirtualQuery failed for %d bytes at address %p
  VirtualProtect failed with code 0x%x
  Unknown pseudo relocation protocol version %d.
  Unknown pseudo relocation bit size %d.
.pdata
RegCloseKey
RegOpenKeyExA
RegQueryValueExA
RegSetValueExA
CloseHandle
CreateFileA
CreateProcessA
CreateRemoteThread
DeleteCriticalSection
EnterCriticalSection
GetComputerNameA
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetLastError
GetStartupInfoA
GetSystemTimeAsFileTime
GetTickCount
InitializeCriticalSection
LeaveCriticalSection
OpenProcess
QueryPerformanceCounter
RtlAddFunctionTable
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
SetUnhandledExceptionFilter
Sleep
TerminateProcess
TlsGetValue
UnhandledExceptionFilter
VirtualAllocEx
VirtualProtect
VirtualQuery
WriteFile
WriteProcessMemory
__C_specific_handler
__getmainargs
__initenv
__iob_func
__lconv_init
__set_app_type
__setusermatherr
_acmdln
_amsg_exit
_cexit
_fmode
_initterm
_onexit
_vsnprintf
abort
calloc
exit
fprintf
free
fwrite
getenv
malloc
memcpy
printf
puts
signal
sprintf
strcmp
strlen
strncmp
vfprintf
ShellExecuteA
MessageBoxA
InternetCloseHandle
InternetOpenA
InternetOpenUrlA
InternetReadFile
WSACleanup
WSAStartup
closesocket
connect
freeaddrinfo
getaddrinfo
htons
inet_addr
socket
ADVAPI32.dll
KERNEL32.dll
msvcrt.dll
SHELL32.dll
USER32.dll
WININET.dll
WS2_32.dll

+------------------------------------+
| FLOSS STATIC STRINGS: UTF-16LE (0) |
+------------------------------------+

 ─────────────────────
  FLOSS STACK STRINGS
 ─────────────────────

AQAPRQVH1
JJM1
RAQH
AXAX^YZAXAYAZH
XAYZH
ws232

 ─────────────────────
  FLOSS TIGHT STRINGS
 ─────────────────────

 ───────────────────────
  FLOSS DECODED STRINGS
 ───────────────────────

```

Déballage des logiciels malveillants packés UPX
-----------------------------------------------

Lors de notre analyse statique, nous pourrions tomber sur un échantillon de logiciel malveillant qui a été compressé ou obscurci à l'aide d'une technique appelée packaging. L'emballage sert à plusieurs fins :

-   Cela obscurcit le code, ce qui rend plus difficile la reconnaissance de sa structure ou de ses fonctionnalités.
-   Il réduit la taille de l'exécutable, le rendant plus rapide à transférer ou moins visible.
-   Cela confond les chercheurs en sécurité en entravant les tentatives traditionnelles d'ingénierie inverse.

Cela peut nuire à l'analyse des chaînes car les références aux chaînes sont généralement masquées ou éliminées. Il remplace ou camoufle également les sections PE conventionnelles avec un stub de chargeur compact, qui récupère le code original d'une section de données compressées. En conséquence, le fichier malveillant devient à la fois plus petit et plus difficile à analyser, car le code d'origine n'est pas directement observable.

Un packer populaire utilisé dans de nombreuses variantes de logiciels malveillants est le `Ultimate Packer for Executables (UPX)`.

Voyons d'abord ce qui se passe lorsque nous exécutons la `strings`commande sur un exemple de malware contenant UPX et nommé `credential_stealer.exe`résidant dans le `C:\Samples\MalwareAnalysis\packed`répertoire de la cible de cette section.

```
C:\Users\htb-student> strings C:\Samples\MalwareAnalysis\packed\credential_stealer.exe

Strings v2.54 - Search for ANSI and Unicode strings in binary images.
Copyright (C) 1999-2021 Mark Russinovich
Sysinternals - www.sysinternals.com

!This program cannot be run in DOS mode.
UPX0
UPX1
UPX2
3.96
UPX!
ff.
8MZu
HcP<H
tY)
L~o
tK1
7c0
VDgxt
amE
8#v
$ /uX
OAUATUWVSH
Z6L
<=h
%0rv
o?H9
7sk
3H{
HZu
'.}
c|/
c`fG
Iq%
[^_]A\A]
> -P
fo{Wnl
c9"^$!=
;\V
%&m
')A
v/7>
07ZC
_L$AAl
mug.%(
t%n
#8%,X
e]'^
(hk
Dks
zC:
Vj<
w~5
m<6
|$PD
c(t
\3_
---SNIP---

```

Observez les chaînes qui incluent `UPX`et notez que le reste du résultat ne fournit aucune information précieuse concernant la fonctionnalité du logiciel malveillant.

![Image](https://academy.hackthebox.com/storage/modules/227/upx_sections.png)

Nous pouvons décompresser le malware à l'aide de l' `UPX`outil (disponible sur `C:\Tools\upx\upx-4.0.2-win64`) avec la commande suivante.

```
C:\Tools\upx\upx-4.0.2-win64> upx -d -o unpacked_credential_stealer.exe C:\Samples\MalwareAnalysis\packed\credential_stealer.exe
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2023
UPX 4.0.2       Markus Oberhumer, Laszlo Molnar & John Reiser   Jan 30th 2023

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
     16896 <-      8704   51.52%    win64/pe     unpacked_credential_stealer.exe

Unpacked 1 file.

```

Exécutons maintenant la `strings`commande sur l'exemple décompressé.

```
C:\Tools\upx\upx-4.0.2-win64> strings unpacked_credential_stealer.exe

Strings v2.54 - Search for ANSI and Unicode strings in binary images.
Copyright (C) 1999-2021 Mark Russinovich
Sysinternals - www.sysinternals.com

!This program cannot be run in DOS mode.
.text
P`.data
.rdata
`@.pdata
0@.xdata
0@.bss
.idata
.CRT
.tls
ff.
8MZu
HcP<H
---SNIP---
D$(
D$
D$0
D$(
D$
t'H
%5T
@A\A]A^
SeDebugPrivilege
SE Debug Privilege is adjusted
lsass.exe
Searching lsass PID
Lsass PID is: %lu
Error is - %lu
lsassmem.dmp
LSASS Memory is dumped successfully
Err 2: %lu
@u@
`p@
Unknown error
Argument domain error (DOMAIN)
Overflow range error (OVERFLOW)
Partial loss of significance (PLOSS)
Total loss of significance (TLOSS)
The result is too small to be represented (UNDERFLOW)
Argument singularity (SIGN)
_matherr(): %s in %s(%g, %g)  (retval=%g)
Mingw-w64 runtime failure:
Address %p has no image-section
  VirtualQuery failed for %d bytes at address %p
  VirtualProtect failed with code 0x%x
  Unknown pseudo relocation protocol version %d.
  Unknown pseudo relocation bit size %d.
.pdata
 0@
00@
`E@
`E@
@v@
hy@
`y@
@p@
0v@
Pp@
AdjustTokenPrivileges
LookupPrivilegeValueA
OpenProcessToken
MiniDumpWriteDump
CloseHandle
CreateFileA
CreateToolhelp32Snapshot
DeleteCriticalSection
EnterCriticalSection
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetLastError
GetStartupInfoA
GetSystemTimeAsFileTime
GetTickCount
InitializeCriticalSection
LeaveCriticalSection
OpenProcess
Process32First
Process32Next
QueryPerformanceCounter
RtlAddFunctionTable
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
SetUnhandledExceptionFilter
Sleep
TerminateProcess
TlsGetValue
UnhandledExceptionFilter
VirtualProtect
VirtualQuery
__C_specific_handler
__getmainargs
__initenv
__iob_func
__lconv_init
__set_app_type
__setusermatherr
_acmdln
_amsg_exit
_cexit
_fmode
_initterm
_onexit
abort
calloc
exit
fprintf
free
fwrite
malloc
memcpy
printf
puts
signal
strcmp
strlen
strncmp
vfprintf
ADVAPI32.dll
dbghelp.dll
KERNEL32.DLL
msvcrt.dll

```

Maintenant, nous observons une sortie plus compréhensible qui inclut les chaînes réelles présentes dans l'échantillon.