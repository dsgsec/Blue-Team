Analyse statique sous Linux
===========================

Dans le domaine de l'analyse des logiciels malveillants, nous utilisons une méthode appelée analyse statique pour examiner les logiciels malveillants sans nécessiter leur exécution. Cela implique une enquête méticuleuse sur le code, les données et les composants structurels des logiciels malveillants, servant de précurseur essentiel à une analyse plus approfondie et plus détaillée.

Grâce à l'analyse statique, nous nous efforçons d'extraire des informations cruciales qui comprennent :

-   Type de fichier
-   Hachage de fichier
-   Cordes
-   Éléments intégrés
-   Informations sur l'emballeur
-   Importations
-   Exportations
-   Code d'assemblage

![Image](https://academy.hackthebox.com/storage/modules/227/static_analysis_flow.png)

Naviguons maintenant vers le bas de cette section et cliquons sur "Cliquez ici pour générer le système cible !". Ensuite, connectons SSH à l'adresse IP cible en utilisant les informations d'identification fournies. La grande majorité des actions/commandes couvertes de ce point à la fin de cette section peuvent être répliquées dans la cible, offrant ainsi une compréhension plus complète des sujets présentés.

Identification du type de fichier
---------------------------------

Notre première étape à ce stade est de vérifier les informations rudimentaires sur le spécimen de malware afin de jeter les bases de notre enquête. Étant donné que les extensions de fichiers peuvent être manipulées et modifiées, notre tâche consiste à concevoir une méthode permettant d'identifier le type de fichier réel que nous rencontrons. L'établissement du type de fichier joue un rôle essentiel dans l'analyse statique, garantissant que les procédures que nous appliquons sont appropriées et que les résultats obtenus sont exacts.

Utilisons à titre d'illustration un malware basé sur Windows nommé `Ransomware.wannacry.exe`résidant dans le `/home/htb-student/Samples/MalwareAnalysis`répertoire de la cible de cette section.

La commande permettant de vérifier le type de fichier de ce malware serait la suivante.

```
dsgsec@htb[/htb]$ file /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
/home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe: PE32 executable (GUI) Intel 80386, for MS Windows

```

Nous pouvons également faire la même chose en vérifiant manuellement l'en-tête à l'aide de la `hexdump`commande suivante.

```
dsgsec@htb[/htb]$ hexdump -C /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe | more
00000000  4d 5a 90 00 03 00 00 00  04 00 00 00 ff ff 00 00  |MZ..............|
00000010  b8 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000030  00 00 00 00 00 00 00 00  00 00 00 00 f8 00 00 00  |................|
00000040  0e 1f ba 0e 00 b4 09 cd  21 b8 01 4c cd 21 54 68  |........!..L.!Th|
00000050  69 73 20 70 72 6f 67 72  61 6d 20 63 61 6e 6e 6f  |is program canno|
00000060  74 20 62 65 20 72 75 6e  20 69 6e 20 44 4f 53 20  |t be run in DOS |
00000070  6d 6f 64 65 2e 0d 0d 0a  24 00 00 00 00 00 00 00  |mode....$.......|
00000080  55 3c 53 90 11 5d 3d c3  11 5d 3d c3 11 5d 3d c3  |U<S..]=..]=..]=.|
00000090  6a 41 31 c3 10 5d 3d c3  92 41 33 c3 15 5d 3d c3  |jA1..]=..A3..]=.|
000000a0  7e 42 37 c3 1a 5d 3d c3  7e 42 36 c3 10 5d 3d c3  |~B7..]=.~B6..]=.|
000000b0  7e 42 39 c3 15 5d 3d c3  d2 52 60 c3 1a 5d 3d c3  |~B9..]=..R`..]=.|
000000c0  11 5d 3c c3 4a 5d 3d c3  27 7b 36 c3 10 5d 3d c3  |.]<.J]=.'{6..]=.|
000000d0  d6 5b 3b c3 10 5d 3d c3  52 69 63 68 11 5d 3d c3  |.[;..]=.Rich.]=.|
000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000f0  00 00 00 00 00 00 00 00  50 45 00 00 4c 01 04 00  |........PE..L...|
00000100  cc 8e e7 4c 00 00 00 00  00 00 00 00 e0 00 0f 01  |...L............|
00000110  0b 01 06 00 00 90 00 00  00 30 38 00 00 00 00 00  |.........08.....|
00000120  16 9a 00 00 00 10 00 00  00 a0 00 00 00 00 40 00  |..............@.|
00000130  00 10 00 00 00 10 00 00  04 00 00 00 00 00 00 00  |................|
00000140  04 00 00 00 00 00 00 00  00 b0 66 00 00 10 00 00  |..........f.....|
00000150  00 00 00 00 02 00 00 00  00 00 10 00 00 10 00 00  |................|
00000160  00 00 10 00 00 10 00 00  00 00 00 00 10 00 00 00  |................|
00000170  00 00 00 00 00 00 00 00  e0 a1 00 00 a0 00 00 00  |................|
00000180  00 00 31 00 54 a4 35 00  00 00 00 00 00 00 00 00  |..1.T.5.........|
00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*

```

Sur un système Windows, la présence de la chaîne ASCII `MZ`(en hexadécimal : `4D 5A`) au début d'un fichier (appelé « nombre magique ») désigne un fichier exécutable. `MZ`signifie Mark Zbikowski, un architecte clé de MS-DOS.

Empreinte digitale des logiciels malveillants
---------------------------------------------

À cette étape, notre mission est de créer un identifiant unique pour l'échantillon de malware. Cela prend généralement la forme d'un hachage cryptographique : MD5, SHA1 ou SHA256.

Les empreintes digitales sont utilisées à de nombreuses fins, notamment :

-   Identification et suivi des échantillons de logiciels malveillants
-   Analyser un système entier pour détecter la présence de logiciels malveillants identiques
-   Confirmation des rencontres précédentes et analyses du même malware
-   Partage avec les parties prenantes en tant qu'IoC (Indicators of Compromise) ou dans le cadre de rapports de renseignements sur les menaces

À titre d'illustration, pour vérifier le hachage du fichier MD5 du malware mentionné ci-dessus, la commande serait la suivante.

```
dsgsec@htb[/htb]$ md5sum /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
db349b97c37d22f5ea1d1841e3c89eb4  /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe

```

Pour vérifier le hachage du fichier SHA256 du malware mentionné ci-dessus, la commande serait la suivante.

```
dsgsec@htb[/htb]$ sha256sum /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
24d004a104d4d54034dbcffc2a4b19a11f39008a575aa614ea04703480b1022c  /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe

```

Recherche de hachage de fichier
-------------------------------

L'étape suivante consiste à vérifier le hachage de fichier produit à l'étape précédente par rapport aux scanners de logiciels malveillants en ligne et aux bacs à sable tels que le bac à sable Cuckoo. Par exemple, VirusTotal, un moteur d'analyse des logiciels malveillants en ligne, qui collabore avec divers fournisseurs d'antivirus, nous permet de rechercher le hachage du fichier. Cette étape nous aide à comparer nos résultats avec les connaissances existantes sur l'échantillon de malware.

L'image suivante affiche les résultats de [VirusTotal](https://www.virustotal.com/gui/home/search) après la soumission du hachage du fichier SHA256 du malware susmentionné.

![Image](https://academy.hackthebox.com/storage/modules/227/virustotal_scan.png)

Même si un hachage de fichier tel que MD5, SHA1 ou SHA256 est utile pour identifier des échantillons identiques portant des noms disparates, il ne suffit pas à identifier des échantillons de logiciels malveillants similaires. Cela est principalement dû au fait qu'un auteur de malware peut modifier la valeur de hachage du fichier en apportant des modifications mineures au code et en le recompilant.

Néanmoins, il existe des techniques qui peuvent aider à identifier des échantillons similaires :

### Importer le hachage (IMPHASH)

`IMPHASH`, abréviation de « Import Hash », est un hachage cryptographique calculé à partir des fonctions d'importation d'un fichier Windows Portable Executable (PE). Son algorithme fonctionne en convertissant d'abord tous les noms de fonctions importés en minuscules. Ensuite, les noms de DLL et les noms de fonctions sont fusionnés et classés par ordre alphabétique. Enfin, un hachage MD5 est généré à partir de la chaîne résultante. Par conséquent, deux fichiers PE avec des fonctions d'importation identiques, dans la même séquence, partageront une `IMPHASH`valeur.

Nous pouvons le trouver `IMPHASH`dans l' `Details`onglet des résultats VirusTotal.

![Image](https://academy.hackthebox.com/storage/modules/227/imphash_vt1.png)

Notez que nous pouvons également utiliser le module [pefile](https://pypi.org/project/pefile/) Python pour calculer l'IMPHASH d'un fichier comme suit.

Code : python

```
import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = pe.get_imphash()

print(imphash)

```

Pour vérifier l'IMPHASH du malware [WannaCry](https://www.fortinet.com/resources/cyberglossary/wannacry-ransomware-attack) mentionné ci-dessus , la commande serait la suivante. `imphash_calc.py`(disponible sur `/home/htb-student`) contient le code Python ci-dessus.

```
dsgsec@htb[/htb]$ python3 imphash_calc.py /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
9ecee117164e0b870a53dd187cdd7174

```

### Hachage flou (SSDEEP)

`Fuzzy Hashing (SSDEEP)`, également appelé hachage par morceaux déclenché par le contexte (CTPH), est une technique de hachage conçue pour calculer une valeur de hachage indicative de la similarité du contenu entre deux fichiers. Cette technique décompose un fichier en blocs plus petits de taille fixe et calcule un hachage pour chaque bloc. Les valeurs de hachage résultantes sont ensuite consolidées pour générer le hachage flou final.

L' `SSDEEP`algorithme accorde plus de poids aux séquences plus longues de blocs communs, ce qui le rend très efficace pour identifier les fichiers qui ont subi des modifications mineures ou qui sont similaires mais non identiques, comme différentes variantes d'un échantillon malveillant.

On peut retrouver le `SSDEEP`hash d'un malware dans l' `Details`onglet des résultats VirusTotal.

Nous pouvons également utiliser la `ssdeep`commande pour calculer le `SSDEEP`hachage d'un fichier. Pour vérifier le `SSDEEP`hachage du malware WannaCry mentionné ci-dessus, la commande serait la suivante.

```
dsgsec@htb[/htb]$ ssdeep /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
ssdeep,1.1--blocksize:hash:hash,filename
98304:wDqPoBhz1aRxcSUDk36SAEdhvxWa9P593R8yAVp2g3R:wDqPe1Cxcxk3ZAEUadzR8yc4gB,"/home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe"

```

![Image](https://academy.hackthebox.com/storage/modules/227/ssdeep_vt1.png)

Les arguments de ligne de commande `-pb`peuvent être utilisés pour lancer le mode de correspondance `SSDEEP`(pendant que nous sommes dans le répertoire où sont stockés les échantillons de logiciels malveillants - `/home/htb-student/Samples/MalwareAnalysis`dans notre cas).

```
dsgsec@htb[/htb]$ ssdeep -pb *
potato.exe matches svchost.exe (99)

svchost.exe matches potato.exe (99)

```

`-p`désigne le mode Pretty matching et `-b`est utilisé pour afficher uniquement les noms de fichiers, sans le chemin complet.

Dans l'exemple ci-dessus, une similarité de 99 % a été observée entre deux échantillons de logiciels malveillants ( `svchost.exe`et `potato.exe`) utilisant `SSDEEP`.

### Hachage de section (hachage de sections PE)

`Section hashing`, (hachage des sections PE) est une technique puissante qui permet aux analystes d'identifier les sections d'un fichier Portable Executable (PE) qui ont été modifiées. Cela peut être particulièrement utile pour identifier des variations mineures dans des échantillons de logiciels malveillants, une tactique courante utilisée par les attaquants pour échapper à la détection.

La `Section Hashing`technique fonctionne en calculant le hachage cryptographique de chacune de ces sections. Lors de la comparaison de deux fichiers PE, si le hachage des sections correspondantes dans les deux fichiers correspond, cela suggère que la section particulière n'a pas été modifiée entre les deux versions du fichier.

En appliquant `section hashing`, les analystes de sécurité peuvent identifier les parties d'un fichier PE qui ont été falsifiées ou modifiées. Cela peut aider à identifier des échantillons de logiciels malveillants similaires, même s'ils ont été légèrement modifiés pour échapper aux méthodes de détection traditionnelles basées sur les signatures.

Des outils tels que `pefile`Python peuvent être utilisés pour effectuer `section hashing`. En Python, par exemple, vous pouvez utiliser le module pefile pour accéder et hacher les données dans des sections individuelles d'un fichier PE comme suit.

Code : python

```
import sys
import pefile
pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
for section in pe.sections:
    print (section.Name, "MD5 hash:", section.get_hash_md5())
    print (section.Name, "SHA256 hash:", section.get_hash_sha256())

```

N'oubliez pas que même s'il `section hashing`s'agit d'une technique puissante, elle n'est pas infaillible. Les auteurs de logiciels malveillants peuvent recourir à des tactiques telles que l'obscurcissement des noms de section ou la génération dynamique de noms de section pour tenter de contourner ce type d'analyse.

A titre d'illustration, pour vérifier les hachages des sections MD5 et SHA256 PE d'un exécutable Wannacry stocké dans le `/home/htb-student/Samples/MalwareAnalysis`répertoire, la commande serait la suivante. `section_hashing.py`(disponible sur `/home/htb-student`) contient le code Python ci-dessus.

```
dsgsec@htb[/htb]$ python3 section_hashing.py /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
b'.text\x00\x00\x00' MD5 hash: c7613102e2ecec5dcefc144f83189153
b'.text\x00\x00\x00' SHA256 hash: 7609ecc798a357dd1a2f0134f9a6ea06511a8885ec322c7acd0d84c569398678
b'.rdata\x00\x00' MD5 hash: d8037d744b539326c06e897625751cc9
b'.rdata\x00\x00' SHA256 hash: 532e9419f23eaf5eb0e8828b211a7164cbf80ad54461bc748c1ec2349552e6a2
b'.data\x00\x00\x00' MD5 hash: 22a8598dc29cad7078c291e94612ce26
b'.data\x00\x00\x00' SHA256 hash: 6f93fb1b241a990ecc281f9c782f0da471628f6068925aaf580c1b1de86bce8a
b'.rsrc\x00\x00\x00' MD5 hash: 12e1bd7375d82cca3a51ca48fe22d1a9
b'.rsrc\x00\x00\x00' SHA256 hash: 1efe677209c1284357ef0c7996a1318b7de3836dfb11f97d85335d6d3b8a8e42

```

Analyse des chaînes
-------------------

Dans cette phase, notre objectif est d'extraire des chaînes (ASCII & Unicode) d'un binaire. Les chaînes peuvent fournir des indices et des informations précieuses sur les fonctionnalités du malware. Parfois, nous pouvons découvrir des chaînes intégrées uniques dans un échantillon de malware, telles que :

-   Noms de fichiers intégrés (par exemple, fichiers supprimés)
-   Adresses IP ou noms de domaine
-   Chemins ou clés de registre
-   Fonctions de l'API Windows
-   Arguments de ligne de commande
-   Informations uniques pouvant faire allusion à un acteur menaçant particulier

La commande Linux `strings`peut être déployée pour afficher les chaînes contenues dans un malware. Par exemple, la commande ci-dessous révélera les chaînes d'un exemple de ransomware nommé `dharma_sample.exe`résidant dans le `/home/htb-student/Samples/MalwareAnalysis`répertoire de la cible de cette section.

```
dsgsec@htb[/htb]$ strings -n 15 /home/htb-student/Samples/MalwareAnalysis/dharma_sample.exe
!This program cannot be run in DOS mode.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@
!"#$%&'()*+,-./0123@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
WaitForSingleObject
InitializeCriticalSectionAndSpinCount
LeaveCriticalSection
EnterCriticalSection
C:\crysis\Release\PDB\payload.pdb
0123456789ABCDEF

```

`-n`spécifie d'imprimer une séquence d'au moins le nombre spécifié - dans notre cas, `15`.

Parfois, l'analyse de chaînes peut faciliter l'association d'un échantillon de malware à un groupe de menaces spécifique si des similitudes significatives sont identifiées. Par [exemple](https://thedfirreport.com/2020/06/16/the-little-ransomware-that-couldnt-dharma/) , dans le lien fourni, une chaîne contenant un chemin PDB a été utilisée pour relier l'échantillon de malware à la famille de ransomwares Dharma/Crysis.

![Image](https://academy.hackthebox.com/storage/modules/227/dharma.png)

* * * * *

Il convient de noter qu'il existe une autre solution d'analyse de chaînes appelée `FLOSS`. `FLOSS`, abréviation de « FireEye Labs Obfuscated String Solver », est un outil développé par l'équipe FLARE de FireEye pour désobscurcir automatiquement les chaînes dans les logiciels malveillants. Il est conçu pour compléter l'utilisation d'outils de chaînes traditionnels, comme la commande strings dans les systèmes Unix, qui peuvent manquer des chaînes obscurcies couramment utilisées par les logiciels malveillants pour échapper à la détection.

Par exemple, la commande ci-dessous révélera les chaînes d'un exemple de ransomware nommé `dharma_sample.exe`résidant dans le `/home/htb-student/Samples/MalwareAnalysis`répertoire de la cible de cette section.

```
dsgsec@htb[/htb]$ floss /home/htb-student/Samples/MalwareAnalysis/dharma_sample.exe
INFO: floss: extracting static strings...
finding decoding function features: 100%|███████████████████████████████████████| 238/238 [00:00<00:00, 838.37 functions/s, skipped 5 library functions (2%)]
INFO: floss.stackstrings: extracting stackstrings from 223 functions
INFO: floss.results: %sh(
extracting stackstrings: 100%|████████████████████████████████████████████████████████████████████████████████████| 223/223 [00:01<00:00, 133.51 functions/s]
INFO: floss.tightstrings: extracting tightstrings from 10 functions...
extracting tightstrings from function 0x4065e0: 100%|████████████████████████████████████████████████████████████████| 10/10 [00:01<00:00,  5.91 functions/s]
INFO: floss.string_decoder: decoding strings
INFO: floss.results: EEED
INFO: floss.results: EEEDnnn
INFO: floss.results: uOKm
INFO: floss.results: %sh(
INFO: floss.results: uBIA
INFO: floss.results: uBIA
INFO: floss.results: \t\t\t\t\t\t\t\t
emulating function 0x405840 (call 4/9): 100%|████████████████████████████████████████████████████████████████████████| 25/25 [00:11<00:00,  2.19 functions/s]
INFO: floss: finished execution after 23.56 seconds

FLARE FLOSS RESULTS (version v2.0.0-0-gdd9bea8)
+------------------------+------------------------------------------------------------------------------------+
| file path              | /home/htb-student/Samples/MalwareAnalysis/dharma_sample.exe                        |
| extracted strings      |                                                                                    |
|  static strings        | 720                                                                                |
|  stack strings         | 1                                                                                  |
|  tight strings         | 0                                                                                  |
|  decoded strings       | 7                                                                                  |
+------------------------+------------------------------------------------------------------------------------+

------------------------------
| FLOSS STATIC STRINGS (720) |
------------------------------
-----------------------------
| FLOSS ASCII STRINGS (716) |
-----------------------------
!This program cannot be run in DOS mode.
Rich
.text
`.rdata
@.data
9A s
9A$v
A +B$
---SNIP---
+o*7
0123456789ABCDEF

------------------------------
| FLOSS UTF-16LE STRINGS (4) |
------------------------------
jjjj
%sh(
ssbss
0123456789ABCDEF

---------------------------
| FLOSS STACK STRINGS (1) |
---------------------------
%sh(

---------------------------
| FLOSS TIGHT STRINGS (0) |
---------------------------

-----------------------------
| FLOSS DECODED STRINGS (7) |
-----------------------------
EEED
EEEDnnn
uOKm
%sh(
uBIA
uBIA
\t\t\t\t\t\t\t\t

```

Déballage des logiciels malveillants packés UPX
-----------------------------------------------

Lors de notre analyse statique, nous pourrions tomber sur un échantillon de logiciel malveillant qui a été compressé ou obscurci à l'aide d'une technique appelée packaging. L'emballage sert à plusieurs fins :

-   Cela obscurcit le code, ce qui rend plus difficile la reconnaissance de sa structure ou de ses fonctionnalités.
-   Il réduit la taille de l'exécutable, le rendant plus rapide à transférer ou moins visible.
-   Cela confond les chercheurs en sécurité en entravant les tentatives traditionnelles d'ingénierie inverse.

Cela peut nuire à l'analyse des chaînes car les références aux chaînes sont généralement masquées ou éliminées. Il remplace ou camoufle également les sections PE conventionnelles avec un stub de chargeur compact, qui récupère le code original d'une section de données compressées. En conséquence, le fichier malveillant devient à la fois plus petit et plus difficile à analyser, car le code d'origine n'est pas directement observable.

Un packer populaire utilisé dans de nombreuses variantes de logiciels malveillants est le `Ultimate Packer for Executables (UPX)`.

Voyons d'abord ce qui se passe lorsque nous exécutons la `strings`commande sur un exemple de malware contenant UPX et nommé `credential_stealer.exe`résidant dans le `/home/htb-student/Samples/MalwareAnalysis/packed`répertoire de la cible de cette section.

```
dsgsec@htb[/htb]$ strings /home/htb-student/Samples/MalwareAnalysis/packed/credential_stealer.exe
!This program cannot be run in DOS mode.
UPX0
UPX1
UPX2
3.96
UPX!
8MZu
HcP<H
VDgxt
$ /uX
OAUATUWVSH
%0rv
o?H9
c`fG
[^_]A\A]
> -P
        fo{Wnl
c9"^$!=
v/7>
07ZC
_L$AAl
mug.%(
#8%,X
e]'^
---SNIP---

```

Observez les chaînes qui incluent `UPX`et notez que le reste du résultat ne fournit aucune information précieuse concernant la fonctionnalité du logiciel malveillant.

Nous pouvons décompresser le malware à l'aide de l' `UPX`outil avec la commande suivante (pendant que nous sommes dans le répertoire où sont stockés les échantillons de malware compressés - `/home/htb-student/Samples/MalwareAnalysis/packed`dans notre cas).

```
dsgsec@htb[/htb]$ upx -d -o unpacked_credential_stealer.exe credential_stealer.exe
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2020
UPX 3.96        Markus Oberhumer, Laszlo Molnar & John Reiser   Jan 23rd 2020

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
     16896 <-      8704   51.52%    win64/pe     unpacked_credential_stealer.exe

Unpacked 1 file.

```

Exécutons maintenant la `strings`commande sur l'exemple décompressé.

```
dsgsec@htb[/htb]$ strings unpacked_credential_stealer.exe
!This program cannot be run in DOS mode.
.text
P`.data
.rdata
`@.pdata
0@.xdata
0@.bss
.idata
.CRT
.tls
---SNIP---
AVAUATH
@A\A]A^
SeDebugPrivilege
SE Debug Privilege is adjusted
lsass.exe
Searching lsass PID
Lsass PID is: %lu
Error is - %lu
lsassmem.dmp
LSASS Memory is dumped successfully
Err 2: %lu
Unknown error
Argument domain error (DOMAIN)
Overflow range error (OVERFLOW)
Partial loss of significance (PLOSS)
Total loss of significance (TLOSS)
The result is too small to be represented (UNDERFLOW)
Argument singularity (SIGN)
_matherr(): %s in %s(%g, %g)  (retval=%g)
Mingw-w64 runtime failure:
Address %p has no image-section
  VirtualQuery failed for %d bytes at address %p
  VirtualProtect failed with code 0x%x
  Unknown pseudo relocation protocol version %d.
  Unknown pseudo relocation bit size %d.
.pdata
AdjustTokenPrivileges
LookupPrivilegeValueA
OpenProcessToken
MiniDumpWriteDump
CloseHandle
CreateFileA
CreateToolhelp32Snapshot
DeleteCriticalSection
EnterCriticalSection
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetLastError
GetStartupInfoA
GetSystemTimeAsFileTime
GetTickCount
InitializeCriticalSection
LeaveCriticalSection
OpenProcess
Process32First
Process32Next
QueryPerformanceCounter
RtlAddFunctionTable
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
SetUnhandledExceptionFilter
Sleep
TerminateProcess
TlsGetValue
UnhandledExceptionFilter
VirtualProtect
VirtualQuery
__C_specific_handler
__getmainargs
__initenv
__iob_func
__lconv_init
__set_app_type
__setusermatherr
_acmdln
_amsg_exit
_cexit
_fmode
_initterm
_onexit
abort
calloc
exit
fprintf
free
fwrite
malloc
memcpy
printf
puts
signal
strcmp
strlen
strncmp
vfprintf
ADVAPI32.dll
dbghelp.dll
KERNEL32.DLL
msvcrt.dll

```

Maintenant, nous observons une sortie plus compréhensible qui inclut les chaînes réelles présentes dans l'échantillon.