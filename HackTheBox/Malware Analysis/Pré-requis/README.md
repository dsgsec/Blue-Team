Éléments internes de Windows
============================

Pour effectuer une analyse efficace des logiciels malveillants, une compréhension approfondie des composants internes de Windows est essentielle. Les systèmes d'exploitation Windows fonctionnent selon deux modes principaux :

-   `User Mode`: C'est dans ce mode que fonctionnent la plupart des applications et des processus utilisateur. Les applications en mode utilisateur ont un accès limité aux ressources système et doivent interagir avec le système d'exploitation via des interfaces de programmation d'applications (API). Ces processus sont isolés les uns des autres et ne peuvent pas accéder directement au matériel ou aux fonctions critiques du système. Cependant, dans ce mode, les logiciels malveillants peuvent toujours manipuler les fichiers, les paramètres de registre, les connexions réseau et d'autres ressources accessibles par l'utilisateur, et peuvent tenter d'élever les privilèges pour obtenir davantage de contrôle sur le système.

-   `Kernel Mode`: En revanche, le mode noyau est un mode hautement privilégié dans lequel le noyau Windows s'exécute. Le noyau dispose d'un accès illimité aux ressources système, au matériel et aux fonctions critiques. Il fournit les services de base du système d'exploitation, gère les ressources système et assure la sécurité et la stabilité. Les pilotes de périphériques, qui facilitent la communication avec les périphériques matériels, s'exécutent également en mode noyau. Si un logiciel malveillant fonctionne en mode noyau, il obtient un contrôle élevé et peut manipuler le comportement du système, dissimuler sa présence, intercepter les appels système et altérer les mécanismes de sécurité.

Architecture Windows à un niveau élevé
--------------------------------------

L'image ci-dessous présente une version simplifiée de l'architecture de Windows.

![Image](https://academy.hackthebox.com/storage/modules/227/windows_architecture.png)

L'architecture Windows simplifiée comprend des composants en mode utilisateur et en mode noyau, chacun ayant des responsabilités distinctes dans le fonctionnement du système.

### Composants en mode utilisateur

`User-mode components`sont les parties du système d'exploitation qui n'ont pas d'accès direct au matériel ou aux structures de données du noyau. Ils interagissent avec les ressources système via des API et des appels système. Discutons de certains d'entre eux :

-   `System Support Processes`: Il s'agit de composants essentiels qui fournissent des fonctionnalités et des services cruciaux tels que les processus de connexion ( `winlogon.exe`), Session Manager ( `smss.exe`) et Service Control Manager ( `services.exe`). Ce ne sont pas des services Windows mais ils sont nécessaires au bon fonctionnement du système.

-   `Service Processes`: Ces processus hébergent des services Windows tels que les services `Windows Update Service`, `Task Scheduler`et . `Print Spooler`Ils s'exécutent généralement en arrière-plan, exécutant des tâches en fonction de leur configuration et de leurs paramètres.

-   `User Applications`: Il s'agit des processus créés par les programmes utilisateur, y compris les applications 32 bits et 64 bits. Ils interagissent avec le système d'exploitation via [les API](https://en.wikipedia.org/wiki/Windows_API) fournies par Windows. Ces appels API sont redirigés vers [NTDLL.DLL](https://en.wikipedia.org/wiki/Microsoft_Windows_library_files#NTDLL.DLL) , déclenchant une transition du mode utilisateur au mode noyau, où l'appel système est exécuté. Le résultat est ensuite renvoyé à l'application en mode utilisateur et une transition vers le mode utilisateur se produit.

-   `Environment Subsystems`: Ces composants sont chargés de fournir des environnements d'exécution pour des types spécifiques d'applications ou de processus. Ils incluent le [sous-système Win32](https://en.wikipedia.org/wiki/Architecture_of_Windows_NT#Win32_environment_subsystem) , [POSIX](https://en.wikipedia.org/wiki/Microsoft_POSIX_subsystem) et [OS/2](https://en.wikipedia.org/wiki/OS/2) .

-   `Subsystem DLLs`: Ces bibliothèques de liens dynamiques traduisent les fonctions documentées en appels système natifs internes appropriés, principalement implémentés dans `NTDLL.DLL`. Les exemples incluent `kernelbase.dll`, `user32.dll`, `wininet.dll`et `advapi32.dll`.

### Composants en mode noyau

`Kernel-mode components`sont les parties du système d'exploitation qui ont un accès direct aux structures de données du matériel et du noyau. Ceux-ci inclus:

-   `Executive`: Cette couche supérieure en mode noyau est accessible via les fonctions de `NTDLL.DLL`. Il se compose de composants tels que `I/O Manager`, `Object Manager`, , et d'autres, gérant les aspects essentiels du système d'exploitation tels que les opérations d'E/S, la gestion des objets, la sécurité et les processus `Security Reference Monitor`. `Process Manager`Il exécute d'abord quelques vérifications, puis transmet l'appel au noyau ou appelle le pilote de périphérique approprié pour effectuer l'opération demandée.

-   `Kernel`: ce composant gère les ressources système, fournissant des services de bas niveau tels que `thread scheduling`, `interrupt and exception dispatching`et `multiprocessor synchronization`.

-   `Device Drivers`: Ces composants logiciels permettent au système d'exploitation d'interagir avec les périphériques matériels. Ils servent d'intermédiaires, permettant au système de gérer et de contrôler les ressources matérielles et logicielles.

-   `Hardware Abstraction Layer (HAL)`: Ce composant fournit une couche d'abstraction entre les périphériques matériels et le système d'exploitation. Il permet aux développeurs de logiciels d'interagir avec le matériel de manière cohérente et indépendante de la plate-forme.

-   `Windowing and Graphics System (Win32k.sys)`: Ce sous-système est responsable de la gestion de l'interface utilisateur graphique (GUI) et du rendu des éléments visuels à l'écran.

Voyons maintenant ce qui se passe en coulisse lorsqu'une application utilisateur appelle une fonction API Windows.

Flux d'appels de l'API Windows
------------------------------

Les logiciels malveillants utilisent souvent des appels d'API Windows pour interagir avec le système et effectuer des opérations malveillantes. En comprenant les détails internes des fonctions API, leurs paramètres et le comportement attendu, les analystes peuvent identifier une utilisation suspecte ou non autorisée de l'API.

Prenons un exemple de flux d'appels d'API Windows, dans lequel une application en mode utilisateur tente d'accéder à des opérations privilégiées et à des ressources système à l'aide de la [fonction ReadProcessMemory](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory) . Cette fonction permet à un processus de lire la mémoire d'un processus différent.

![Image](https://academy.hackthebox.com/storage/modules/227/wininternals_syscall.png)

Lorsque cette fonction est appelée, certains paramètres requis lui sont également transmis, tels que le handle du processus cible, l'adresse source à partir de laquelle lire, un tampon dans son propre espace mémoire pour stocker les données lues et le nombre d'octets à lire. lire. Vous trouverez ci-dessous la syntaxe de `ReadProcessMemory`la fonction WINAPI selon la documentation Microsoft.

```
BOOL ReadProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPCVOID lpBaseAddress,
  [out] LPVOID  lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesRead
);

```

![Image](https://academy.hackthebox.com/storage/modules/227/msdn_003_readprocessmemory.png)

`ReadProcessMemory`est une fonction API Windows qui appartient à la `kernel32.dll`bibliothèque. Ainsi, cet appel est invoqué via le `kernel32.dll`module qui sert d'interface en mode utilisateur à l'API Windows. En interne, le `kernel32.dll`module interagit avec le `NTDLL.DLL`module, qui fournit une interface de niveau inférieur au noyau Windows. Ensuite, cette demande de fonction est traduite en appel d'API native correspondant, à savoir `NtReadVirtualMemory`. La capture d'écran ci-dessous `x64dbg`montre à quoi cela ressemble dans un débogueur.

![Image](https://academy.hackthebox.com/storage/modules/227/x64dbg_readprocessmemory.png)

Le `NTDLL.DLL`module utilise des appels système (syscalls).

![Image](https://academy.hackthebox.com/storage/modules/227/msdn_004_syscall_instruction.png)

L' `syscall`instruction déclenche l'appel système en utilisant les paramètres définis dans les instructions précédentes. Il transfère le contrôle du mode utilisateur au mode noyau, où le noyau effectue l'opération demandée après avoir validé les paramètres et vérifié les droits d'accès du processus appelant.

Si la requête est autorisée, le thread passe du mode utilisateur au mode noyau. Le noyau gère une table appelée le `System Service Descriptor Table (SSDT)`ou le `syscall table (System Call Table)`, qui est une structure de données contenant des pointeurs vers les différentes routines de service système. Ces routines sont chargées de gérer les appels système effectués par les applications en mode utilisateur. Chaque entrée de la table d'appel système correspond à un numéro d'appel système spécifique, et le pointeur associé pointe vers la fonction du noyau correspondante qui implémente l'opération demandée.

L'appel système responsable `ReadProcessMemory`est exécuté dans le noyau, où les mécanismes de gestion de la mémoire Windows et d'isolation des processus sont exploités. Le noyau effectue les validations, les contrôles d'accès et les opérations de mémoire nécessaires pour lire la mémoire du processus cible. Le noyau récupère les pages de mémoire physique correspondant aux adresses virtuelles demandées et copie les données dans le tampon fourni.

Une fois que le noyau a fini de lire la mémoire, il repasse le thread en mode utilisateur et le contrôle est rendu à l'application en mode utilisateur d'origine. L'application peut alors accéder aux données lues dans la mémoire du processus cible et poursuivre son exécution.

Naviguons maintenant vers le bas de cette section et cliquons sur "Cliquez ici pour générer le système cible !". Ensuite, passons à RDP dans l'adresse IP cible en utilisant les informations d'identification fournies. La grande majorité des actions/commandes couvertes de ce point à la fin de cette section peuvent être répliquées dans la cible, offrant ainsi une compréhension plus complète des sujets présentés.

```
dsgsec@htb[/htb]$ xfreerdp /u:htb-student /p:'HTB_@cademy_stdnt!' /v:[Target IP] /dynamic-resolution

```

Exécutable portable
-------------------

Les systèmes d'exploitation Windows utilisent ce `Portable Executable (PE)`format pour encapsuler des programmes exécutables, `DLLs (Dynamic Link Libraries)`ainsi que d'autres composants intégrés du système. Dans le domaine de l'analyse des logiciels malveillants, une compréhension approfondie du format de fichier PE est indispensable. Cela nous permet d'obtenir des informations significatives sur la structure, les opérations et les activités malveillantes potentielles de l'exécutable intégrées dans le fichier.

Les fichiers PE acceptent une grande variété de types de données, notamment , `executables (.exe)`, , et bien d'autres. Le format de fichier PE est fondamentalement une structure de données contenant les informations vitales nécessaires au chargeur du système d'exploitation Windows pour gérer le code exécutable, en le chargeant efficacement en mémoire.`dynamic link libraries (.dll)``kernel modules (.srv)``control panel applications (.cpl)`

### Sections PE

La Structure PE abrite également un `Section Table`, élément comprenant plusieurs sections dédiées à des finalités distinctes. Les sections sont essentiellement les référentiels où est stocké le contenu réel du fichier, y compris les données, les ressources utilisées par le programme et le code exécutable. Cette `.text`section est souvent surveillée à la recherche d'artefacts potentiels liés aux attaques par injection.

Les sections PE courantes comprennent :

-   `Text Section (.text)`: Le hub où réside le code exécutable du programme.
-   `Data Section (.data)`: Un stockage pour les variables de données globales et statiques initialisées.
-   `Read-only initialized data (.rdata)`: héberge des données en lecture seule telles que des valeurs constantes, des chaînes littérales et des variables globales et statiques initialisées.
-   `Exception information (.pdata)`: Une collection d'entrées de table de fonctions utilisées pour la gestion des exceptions.
-   `BSS Section (.bss)`: Contient les variables de données globales et statiques non initialisées.
-   `Resource Section (.rsrc)`: Protège les ressources telles que les images, les icônes, les chaînes et les informations de version.
-   `Import Section (.idata)`: Détails sur les fonctions importées depuis d'autres DLL.
-   `Export Section (.edata)`: Informations sur les fonctions exportées par l'exécutable.
-   `Relocation Section (.reloc)`: Détails pour déplacer le code et les données de l'exécutable lorsqu'il est chargé à une adresse mémoire différente.

Nous pouvons visualiser les sections d'un exécutable portable à l'aide d'un outil comme `pestudio`celui illustré ci-dessous.

![Image](https://academy.hackthebox.com/storage/modules/227/pe_sections.png)

Se plonger dans le format de fichier Portable Executable (PE) est essentiel pour l'analyse des logiciels malveillants, offrant des informations sur la structure du fichier, l'analyse du code, les fonctions d'importation et d'exportation, l'analyse des ressources, les techniques anti-analyse et l'extraction d'indicateurs de compromission. Notre compréhension de ces fondements ouvre la voie à une analyse efficace des logiciels malveillants.

Processus
---------

En termes simples, un processus est une instance d'un programme en cours d'exécution. Il représente une tranche de l'exécution d'un programme en mémoire et se compose de diverses ressources, notamment de la mémoire, des descripteurs de fichiers, des threads et des contextes de sécurité.

![Image](https://academy.hackthebox.com/storage/modules/227/process_internals.png)

Chaque processus est caractérisé par :

-   `A unique PID (Process Identifier)`: Un identifiant de processus (PID) unique est attribué à chaque processus au sein du système d'exploitation. Cet identifiant numérique facilite le suivi et la gestion du processus par le système d'exploitation.

-   `Virtual Address Space (VAS)`: Dans le système d'exploitation Windows, chaque processus se voit attribuer son propre espace d'adressage virtuel, offrant une vue virtualisée de la mémoire du processus. Le VAS est divisé en segments, comprenant des segments de code, de données et de pile, permettant au processus d'accéder à la mémoire isolée.

-   `Executable Code (Image File on Disk)`: Le code exécutable, ou le fichier image, désigne le fichier exécutable binaire stocké sur le disque. Il abrite les instructions et les ressources nécessaires au fonctionnement du processus.

-   `Table of Handles to System Objects`: Les processus maintiennent une table de handles, un catalogue de référence pour divers objets système. Les objets système peuvent s'étendre sur des fichiers, des appareils, des clés de registre, des objets de synchronisation et d'autres ressources.

-   `Security Context (Access Token)`: Chaque processus est associé à un contexte de sécurité, incarné par un `Access Token`. Cela `Access Token`encapsule les informations sur les privilèges de sécurité du processus, y compris le compte utilisateur sous lequel le processus fonctionne et les droits d'accès accordés au processus.

-   `One or More Threads Running in its Context`: Les processus se composent d'un ou plusieurs threads, où un thread incarne une unité d'exécution au sein du processus. Les threads permettent une exécution simultanée au sein du processus et facilitent le multitâche.

Bibliothèque de liens dynamiques (DLL)
--------------------------------------

Une bibliothèque de liens dynamiques (DLL) est un type de PE qui représente « la mise en œuvre par Microsoft du concept de bibliothèque partagée dans le système d'exploitation Microsoft Windows ». Les DLL exposent un éventail de fonctions qui peuvent être exploitées par des logiciels malveillants, que nous examinerons plus tard. Tout d'abord, démêlons les fonctions d'importation et d'exportation dans une DLL.

### Fonctions d'importation

-   Les fonctions d'importation sont des fonctionnalités auxquelles un binaire est lié dynamiquement à partir de bibliothèques ou de modules externes pendant l'exécution. Ces fonctions permettent au binaire d'exploiter les fonctionnalités offertes par ces bibliothèques.

-   Lors de l'analyse des logiciels malveillants, l'examen des fonctions d'importation peut mettre en lumière les bibliothèques ou modules externes dont dépend le logiciel malveillant. Ces informations aident à identifier les API avec lesquelles le logiciel malveillant peut interagir, ainsi que les ressources telles que le système de fichiers, les processus, le registre, etc.

-   En identifiant les fonctions spécifiques importées, il devient possible de déterminer les actions que le malware peut effectuer, telles que les opérations sur les fichiers, la communication réseau, la manipulation du registre, etc.

-   Les noms ou hachages des fonctions d'importation peuvent servir d'IOC (indicateurs de compromission) qui aident à identifier les variantes de logiciels malveillants ou les échantillons associés.

Vous trouverez ci-dessous un exemple d'identification de l'injection de processus à l'aide des importations de DLL et des noms de fonctions :

![Image](https://academy.hackthebox.com/storage/modules/227/process_injection_fn.png)

Dans ce diagramme, le processus malveillant ( `shell.exe`) effectue une injection de processus pour injecter du code dans un processus cible ( `notepad.exe`) à l'aide des fonctions suivantes importées de la DLL`kernel32.exe` :

-   `OpenProcess`: Ouvre un handle vers le processus cible (notepad.exe), fournissant les droits d'accès nécessaires pour manipuler sa mémoire.
-   `VirtualAllocEx`: alloue un bloc de mémoire dans l'espace d'adressage du processus cible pour stocker le code injecté.
-   `WriteProcessMemory`: Écrit le code souhaité dans le bloc mémoire alloué du processus cible.
-   `CreateRemoteThread`: Crée un nouveau thread au sein du processus cible, en spécifiant le point d'entrée du code injecté comme point de départ.

En conséquence, le code injecté est exécuté dans le contexte du processus cible par le thread distant nouvellement créé. Cette technique permet au malware d'exécuter du code arbitraire au sein du processus cible.

Les fonctions ci-dessus sont des fonctions WINAPI (Windows API). Ne vous inquiétez pas des fonctions WINAPI pour le moment. Nous en discuterons en détail plus tard.

Nous pouvons examiner les importations de DLL de `shell.exe`(résidant dans le `C:\Samples\MalwareAnalysis`répertoire) en utilisant `CFF Explorer`(disponible sur `C:\Tools\Explorer Suite`) comme suit.

![Image](https://academy.hackthebox.com/storage/modules/227/imports_.png)

### Fonctions d'exportation

-   Les fonctions d'exportation sont les fonctions qu'un binaire expose pour être utilisées par d'autres modules ou applications.

-   Ces fonctions fournissent une interface permettant à d'autres logiciels d'interagir avec le binaire.

* * * * *

Dans la capture d'écran ci-dessous, nous pouvons voir un exemple d'importations de DLL (en utilisant `CFF Explorer`) et d'exportations (en utilisant l'onglet `x64dbg`- `Symbols`) :

-   `Imports`: Ceci montre les DLL et leurs fonctions importées par un exécutable `Utilman.exe`.

-   `Exports`: Ceci montre les fonctions exportées par une DLL `Kernel32.dll`.

![Image](https://academy.hackthebox.com/storage/modules/227/dll_imports_exports.png)

Dans le contexte de l'analyse des logiciels malveillants, la compréhension des fonctions d'importation et d'exportation aide à discerner le comportement, les capacités et les interactions du binaire avec des entités externes. Il fournit des informations précieuses pour la détection des menaces, la classification et l'évaluation de l'impact des logiciels malveillants sur le système.