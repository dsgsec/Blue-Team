# Analyse mémoire cheatsheet

## Yarascan 

Le module Yarascan de Volatility permet de rechercher des octets, des chaînes ou d’appliquer des ensembles de règles sur les processus lancés dans le dump mémoire.

### Commande de Base

```
vol.py -f <dump.mem> --profile=<profile> yarascan <options> <pattern>
```

### Options Disponibles

- `-c` : Recherche insensible à la casse.
- `-A` : Recherche en mémoire des processus et du noyau.
- `-Y` ou `-U` : Chaine à rechercher (selon les versions de Volatility).

### Exemple d’Utilisation

Recherche de la chaîne '189.196.140.187' dans le dump mémoire, en ignorant la casse et en incluant les processus et le noyau :

```
vol.py -f dump.mem --profile=Win7SP1x64 yarascan -c -A -Y '189.196.140.187'
```

Dans cet exemple, le module Yarascan recherche la chaîne spécifiée dans le dump mémoire, en ignorant la casse et en incluant les processus et le noyau dans la recherche.

## Dlllist 

La commande `dlllist` de Volatility liste les DLL chargées dans le processus visé en se basant sur sa PEB (Process Environment Block), ce qui est utile en cas de suspicion de malware.

### Commande de Base

```
volatility -f <dump.mem> --profile=<profile> dlllist -p <pid>
```

### Options Disponibles

- `-f <dump.mem>` : Spécifie le fichier dump mémoire.
- `--profile=<profile>` : Spécifie le profil Volatility à utiliser.
- `dlllist` : Commande pour lister les DLL.
- `-p <pid>` : ID du processus cible.

### Exemple d’Utilisation

```
volatility -f dump.mem --profile=Win2016x64_14393 dlllist -p <pid>
```

Dans cet exemple, la commande `dlllist` liste les DLL chargées dans le processus identifié par `<pid>` dans le dump mémoire spécifié.

### Extraction de DLL Malveillante

En cas de DLL malveillante identifiée, il est possible de l’extraire via `dlldump`. Par exemple :

```
volatility -f dump.mem --profile=Win2016x64_14393 dlldump -p <pid> -b <base_address> -D <output_directory>
```

Cette commande extrait la DLL malveillante du processus spécifié vers un répertoire de sortie.


## Ldrmodules

La commande `ldrmodules` de Volatility liste depuis la VAD (Virtual Address Descriptor - Table d’espace mémoire allouée à chaque processus) les éléments liés au processus.

### Commande de Base

```
volatility -f <dump.mem> --profile=<profile> ldrmodules -p <pid>
```

### Options Disponibles

- `-f <dump.mem>` : Spécifie le fichier dump mémoire.
- `--profile=<profile>` : Spécifie le profil Volatility à utiliser.
- `ldrmodules` : Commande pour lister les modules liés au processus.
- `-p <pid>` : ID du processus cible.

### Concepts Importants

- **VAD (Virtual Address Descriptor)** : Chaque processus possède une VAD dans le kernel, qui sert à indiquer les espaces d’adresse de chaque processus.

### Exemple d’Utilisation

```
volatility -f dump.mem --profile=Win2016x64_14393 ldrmodules -p <pid>
```

Dans cet exemple, la commande `ldrmodules` liste les éléments liés au processus identifié par `<pid>` depuis la VAD dans le dump mémoire spécifié.

### Remarque

Certaines informations du malveillant affichées de manière “légitimes” dans la PEB seront affichées de manière réelles dans la VAD.
**PAS DE CHEMIN = INJECTION**

## Malfind 

La commande `malfind` de Volatility recherche les injections de processus (shellcode, exécutables et DLL) à l'intérieur des processus. Elle se base sur l’état de la mémoire et le contenu des espaces alloués non déclarés.

### Commande de Base

```
volatility -f <dump.mem> --profile=<profile> malfind -p <pid>
```

### Options Disponibles

- `-f <dump.mem>` : Spécifie le fichier dump mémoire.
- `--profile=<profile>` : Spécifie le profil Volatility à utiliser.
- `malfind` : Commande pour rechercher les injections de processus.
- `-p <pid>` : ID du processus cible.

### Exemple d’Utilisation

```
volatility -f dump.mem --profile=Win7SP1x64 malfind -p <pid>
```

Dans cet exemple, la commande `malfind` recherche les injections de processus dans le processus identifié par `<pid>` dans le dump mémoire spécifié.

### Remarques

- Le MZ ainsi que l'état de protection `PAGE_EXECUTE_READWRITE` confirment la présence d’un exécutable injecté dans `svchost.exe`.
- Le flag `PAGE_EXECUTE_READWRITE` indique que l’espace mémoire du processus a été modifié, notamment par les fonctions `VirtualAlloc` et `VirtualAllocEx` lors de l'allocation.
- Lors d’une injection de DLL, si `LoadLibraryA` est utilisé par le thread, la DLL apparaîtra dans `dlllist` car elle sera chargée comme DLL légitime, notamment pour effectuer de l’API hooking. Cependant, si la DLL est chargée pour exécuter un code malveillant (reverse shell, etc.), elle ne sera pas visible dans `dlllist`, et dans ce cas `malfind` pourra potentiellement l’identifier.

## Hollowfind

### Commande de Base

```
volatility -f <dump.mem> --profile=<profile> hollowfind
```

### Options Disponibles

```
-f <dump.mem> : Spécifie le fichier dump mémoire.
--profile=<profile> : Spécifie le profil Volatility à utiliser.
hollowfind : Commande pour rechercher les anomalies de processus.
```

### Exemple d’Utilisation

```
volatility -f dump.mem --profile=Win7SP1x64 hollowfind
```

Dans cet exemple, la commande `hollowfind` est utilisée pour rechercher les anomalies de processus dans le dump mémoire spécifié.

### Remarques

- Possibilité de dump via l'option `-D`, mais celle-ci n'est pas incluse dans cet exemple.

## Analyse Rootkit
--------------------


## Analyse des Modules

Le module `modules` liste les drivers dans l’ordre auquel ils ont été chargés par le système.

Commande :
```
vol.py -f laqma.vmem --profile=Win7SP1x86 modules
```

`modscan` peut venir en complément pour scanner l’espace d’adresse physique (pool tag) et identifier les modules non liés et les modules précédemment chargés (dans le cas où le rootkit cacherait sa présence).

Commande :
```
vol.py -f laqma.vmem --profile=Win7SP1x86 modscan
```

## Analyse de la SSDT (System Service Dispatch Table)

Le module `ssdt` recherche si des fonctions indexées dans la SSDT sont hookés.

Commande :
```
vol.py -f mem02.vmem --profile=Win7SP1x64 ssdt
```

La commande ci-dessous exclut les résultats des hooks générés par `win32k.sys` et `ntoskrnl.exe`, qui sont légitimes sauf en cas de backdoor.
```
vol.py -f mem02.vmem --profile=Win7SP1x64 ssdt | grep -vi 'ntos\|win32k'
```

La SSDT (System Service Dispatch Table) est un tableau de descripteur de service situé dans le kernel Windows. Il est utilisé pour diriger les syscall vers le traitement approprié, fonctionnant comme une table d’adressage des API en quelque sorte. Il s’agit d’une protection contre les rootkit, bien que cette protection puisse être contournée.

## Analyse des CallBacks Kernel

Le module `callbacks` recherche si des fonctions du noyau peuvent être hookés (via un driver inséré dans le kernel).

Commande :
```
vol.py -f dump.mem --profile=Win7SP1x64 callbacks
```

Ce module permet de détecter les hookings de fonctions du noyau, ce qui peut indiquer la présence de malware ou de rootkits.

