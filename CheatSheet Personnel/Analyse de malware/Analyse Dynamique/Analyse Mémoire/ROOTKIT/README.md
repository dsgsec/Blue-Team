## Rootkit Cheatsheet

### Rôle d'un Rootkit

Le rôle d’un rootkit est de modifier le comportement d’une machine dans le but de dissimuler sa présence, souvent là où un virus se reproduit.

### Types de Rootkits

- **Virtualisation (VMBR) :** Modifie la chaîne de démarrage (boot) pour être chargé en tout premier. L’OS devient alors un hôte (invité) du rootkit. Aussi appelé Bootkit.
- **Noyau (DKOM) :** S’insère dans le kernel via le chargement d’un driver. Permet de masquer les processus tiers, les pilotes, les fichiers et les connexions intermédiaires du gestionnaire de tâches et du planificateur d’événements.
- **Bibliothèque :** Intercepte les syscalls et remplace les fonctions des API, masquant la présence du malveillant.
- **Programme :** Remplace des binaires légitimes par des imitations backdoorés modifiant le comportement de l’application.

### Techniques

- **VMBR (Virtual-Machine Based Rootkit) :** Technique invisible par la machine hôte, le rootkit intercepte via la VMM (Virtual Machine Monitor) les nombreux I/O vers la machine virtuelle.
- **DKOM (Direct Kernel Object Manipulation) :** Permet de masquer les processus tiers, les pilotes, les fichiers et les connexions intermédiaires du gestionnaire de tâches et du planificateur d’événements.

### Sécurités Contre les Rootkits Kernel Driver

- **Kernel Mode Code Signing (KMCS) :** Oblige le driver à être signé.
- **Kernel Patch Protection (KPP) :** Protection contre la modification des composants système comme la SSDT, IDT, et autres structures/tables de données.

## Hooks d'API et DKOM - CallBacks

### Hooks d'API

Les hooks d’API permettent d‘intercepter les appels systèmes d’un processus pour ajouter des instructions ou modifier les I/O retourné par le processus à l’utilisateur.

L'attaquant patche dans l'IAT l'adresse de la fonction (servie par l'API Windows) à hooker. Tout appel à cette fonction sera détourné vers la fonction malveillante (DLL) que l’attaquant aura chargée dans le processus.

Quand une application souhaite appeler une fonction de l'API, elle n'appelle pas directement la DLL correspondante mais utilise plutôt une table locale appelée l'IAT ("Import Address Table") qui liste les adresses des fonctions de toutes les DLL utilisées par l'application. L'IAT est donc une table qui permet de "lier" l'application aux différentes DLL du système.

#### Explication de l’attaque (après l’injection de la DLL)

**Étape 1: Interception de l'appel**
Lorsqu'un taskmgr tente d'appeler EnumProcesses, il accède à cette fonction via la Import Address Table (IAT), qui aura été modifiée par le rootkit. Au lieu de pointer vers la fonction EnumProcesses réelle dans le DLL du système, l'entrée de l'IAT pointe vers une fonction contrôlée par le rootkit. L'appel de à EnumProcesses est donc redirigé vers la fonction du rootkit.

**Étape 2: Traitement par le Rootkit**
- **Exécution de l'Original :** La fonction interceptée du rootkit commence par invoquer la vraie fonction EnumProcesses. Cela peut être réalisé soit en appelant la fonction originale à partir d'une copie sauvegardée de son adresse avant la modification de l'IAT, soit en utilisant une autre technique pour accéder à la version non modifiée de la fonction.
- **Récupération des Données :** La vraie fonction EnumProcesses exécute normalement son opération, récupérant la liste complète des processus actifs et renvoyant ces données à la fonction du rootkit.

**Étape 3: Manipulation des Données**
- **Analyse et Filtrage :** La fonction du rootkit reçoit les données (typiquement, un tableau d'identifiants de processus). Elle analyse cette liste et détermine quels processus sont associés au rootkit ou à d'autres logiciels malveillants qu'elle souhaite cacher.
- **Modification des Résultats :** Les identifiants des processus à cacher sont soit supprimés du tableau, soit modifiés pour pointer vers des processus inoffensifs.

**Étape 4: Renvoi des Données Modifiées**
Retour à l'Application : Une fois les modifications effectuées, la fonction du rootkit renvoie la liste modifiée des processus à l'application appelante. L'application, ne se doutant de rien, traite cette liste comme si elle était la liste originale des processus en cours d'exécution sur le système.

### DKOM - CallBacks

Les mécanismes de Kernel CallBack permettent de hooker les évènements systèmes depuis le kernel directement. Quelques méthodes de callbacks :
- **PsSetLoadImageNotifyRoutine :** inscrit un rappel pour le pilote qui sera ensuite notifié chaque fois qu’une image (par exemple, une DLL ou EXE) est chargée (ou mappée en mémoire).
- **PsSetCreateThreadNotifyRoutine :** indique une routine qui est appelée chaque fois qu'un thread démarre ou se termine.
- **PsSetCreateProcessNotifyRoutine :** lorsqu'un processus démarre ou se termine, ce rappel est invoqué (rootkits et AV).
- **DbgSetDebugPrintCallback :** il est utilisé pour capturer le débogage de messages.
- **IoRegisterFsRegistrationChange :** Fournit une notification lorsqu'un système de fichiers devient disponible.
- **IoRegisterShutdownNotification :** Inscrit le pilote pour recevoir un IRP IRP_MJ_SHUTDOWN lorsque le système est arrêté.
- **KeRegisterBugCheckCallback :** Aide les pilotes à recevoir un notification avant un crash système.
